# 4. 백엔드 만들기



## 1. 백엔드 코딩 준비하기

### 1.  오래된 npm 버전검색, 업데이트

```bash
npm outdated

npm update
```

### 2. node.js LTS 버전설치하기

- 

### 3. mySQL 설치하기(communitiy 버전)

- 8버전은 비밀번호체계가 다르므로, 조금 복잡하다. 5버전을 설치한다.
- ㅇ

### 4. back 폴더 생성하기

- back 폴더안에서 express 설치한다.

```bash
npm init

npm i express
```

- 설치 후, app.js 파일 생성한다.
- node는 require, experts를 사용한다.

```js
// back/app.js

const express = require('express');
const app = express();


db.sequelize.sync();

app.use(morgan('dev'))

// 메인페이지를 가져오는 것
app.get('/', (req, res) => {
  res.status(200).send('여기는 백엔드');
  // res.send('(수정)여기는 남승현');
})



app.listen(3085, () => {
  console.log(`백엔드 서버 ${3085}번 프로에서 작동중...`)
  console.log()
  console.log(`http://localhost:${3085}/`)
})
```

- packages.json의 dev에 node app.js를 입력한다.

```json
// back/package.json

{
  ...,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon app.js"
  },
  ...,
}

```



## 2. 백엔드 기본 개념 이해하기

- 프론트, 백엔드, DB 서버를 각각 나누는 이유는, 서버 증설이 필요할 경우, 해당 파트만 서버증설을 용이하게 하기 위해서이다.
- 프론트는 백엔드에 request(요청)을 보내고, 백엔드는 프론트에 response(응답)을 보낸다.
- 프론트는 소스코드를 공개하기때문에 DB로 직접 접근할 경우, DB 접근 키의 값이 노출이 되서 보안에 치명적이기때문에 백엔드에서 DB로 접근 한 뒤, 해당 정보를 프론트로 보내주는 방식으로 한다.
- HTTP
  - GET - 가져옴
  - POST - 생성
  - PUT - 전체 수정
  - PATCH - 일부 수정
  - DELETE - 삭제
  - OPTIONS - 찔러보기
  - http: 80 서버
  - https: 443 서버



## 3.  시퀄라이즈 도입하기

### 1. DB는 시퀄라이즈를 사용한다.

```bash
// back/

npm i sequelize mysql2

npm i -D sequelize-cli

npm sequlize init
```

- sequelize는 DB를 JS로 접근할 수 있게 해준다.
- mysql2 는 nodeJS와 mySQL을 연결시켜주는 드라이버이다.
- -D로 설치를 하는 이유는 -g로 설치를 할 경우 package.json에 기록이 안 되기 때문에, 협업을 할 경우, 필요한 패키지 설치가 누락될 가능성이 있기 때문이다.

### 2.  models/index.js 수정하기

- 기본적으로 아래와 같은 기능만 사용한다.

```js
// back/models/index.js

const Sequelize = require('sequelize');
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

const sequelize = new Sequelize(config.database, config.username, config.password, config);

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
```

### 3. config/config.json 수정하기

- mysql에서 접근하기 위한 username과 password를 설정한다.
- mysql 폴더이름은 database도 변경한다.

```json
// back/config/config.json

{
  "development": {
    "username": "root",
    "password": "q1w2e3r41234",
    "database": "vue-nodebird",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  ...,
}
```



## 4. 서버로 데이터 보내기

### 1. 서버의 코드를 수정할 경우 서버를 재시작해야하는 번거로움이 있다.

- 이를 해결할 nodemon을 설치한다.

```bash
// back

npm i -D nodemon
```

- nodemon은 서버의 코드가 변깅이 되면 자동으로 재시작해준다. (새로고침만 하면 된다.)
- package.json의 dev 부분을 수정한다. (node -> nodemon)

```json
// back/package.json

{
  ...,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon app.js"
  },
  ...,
}
```



### 2.  회원가입 연결하기

### 1. axios 연결

- front/nuxt.config.js 에 axios를 등록했기 때문에 axios 사용이 가능하다.
  - 프론트에서 this$axios.get('/') 형식으로 보내면,
  - 백엔드에서는 app.get('/')으로 받는다. ( app = express() )
- 회원가입은 생성(POST)이기 때문에 POST요청을 보낸다.
  - 형식이 있는 데이터는 header에 보낸다.
  - 자유로운 데이터는 body에 넣어서 보낸다.

- setMe()에 console.log(this.$axios) 추가하고 내용을 확인한다.

```
// consol

ƒ wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  }
```

- 백엔드에서 express는 JSON을 받지 못한다는 담점이 있다. 따라서 아래 두 가지문자을 추가한다.

```js
// back/app.js

app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```

- express.json() 은 JSON 데이터를 해석해서 req에 넣어주는 역할을 한다.
- express.urlencoded({ extended: false }) 은 form에서 actions을 전송할 대 그 데이터를 해석해서 req에 넣어주는 역할을 한다.

### 2. DB생성

- axios로 넘어온 데이터를 db에 저장을 해야 한다.
- 1) models/user.js 파일을 생성한다.
- 2) User라는 이름의 db를 만들고, email, nickname, password를 넣어준다.
- 3) 한글 입력을 위해 utf8 성정을 하고, utf8_general_cidmf 을 사용하면, 한글저장이 가능해진다.
- 4) sequelize는 updatedAt, createdAt, 고유 ID를 자동으로 생성해서 추가해준다.

```js
// back/models/user.js

module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    email: {
      type: DataTypes.STRING(40), // 40자 이내
      allowNull: false, // 필수
      unique: true, // 중복금지
    },
    nickname: {
      type: DataTypes.STRING(20),
      allowNull: false,
    },
    password: {
      type: DataTypes.STRING(100),
      allowNull: false,
    },
  }, {
    charset: 'utf8',
    collate: 'utf8_general_ci', // 한글 저장돼요
  });

  User.associate = (db) => {
    db.User.hasMany(db.Post)
    db.User.hasMany(db.Comment)
  };
  
  return User;
};
```

- 5) user.js를 index.js에 등록한다.

```js
// back/models/index.js

...,
db.User = require('./user')(sequelize, Sequelize);

...,
module.exports = db;
```

- 6) 등록이 됨으로써 db에 User가 들어가 있다. app.js에 등록을 한다.
- 7) 또한 db를 실행하기 위해 db.sequelize.sync()를 추가한다.

```js
// back/app.js

...,
const db = require('./models');
const userRouter = require('./routes/user');

db.sequelize.sync();

app.use('/user', userRouter)

...,
```

- 8) mySQL 내부에 back/config/config.json에 database에 작성한vue-ndebird 데이터베이스(SCHEMA)를 만들어야 한다. 

```bash
// back

npx sequelize db:create
```

### 3. 시퀄라이즈 모델과 회원가입

- npm run dev를 실행하면 아래의 결과가 보여진다. sequelize를 통해 js로 sql문을 구현한 것이다. (ORM)

```
// back - terminal

CREATE TABLE IF NOT EXISTS `Users` (`id` INTEGER NOT NULL auto_increment , `email` VARCHAR(40) NOT NULL, `nickname` VARCHAR(20) NOT NULL, `password` VARCHAR(50) NOT NULL, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE utf8_general_ci;
```

- 1) 회원가입을 시도하게 되면 아래와 같은 cors에러가 발생한다.
  - ![cors_error](https://user-images.githubusercontent.com/50367487/71822253-c5a13600-30d7-11ea-873b-4e8a11b9c6b9.PNG)
  - 백엔드는 일반적으로 서버가 다른 axios 요청을 거절(차단)한다.
  - 이를 도와줄 cors 패키지를 설치한다.
  - cors를 app.js에 등록한다.
  - cors에 허용할 주소만 정확히 입력한다.

```bash
// back

npm i cors
```

```js
// back/app.js

const cors = require('cors');

app.use(cors('http://localhost:3000'));
```

- 2) 다시 회원가입을 실행시키고, network창을 확인하면 비밀번호가 보여진다.
  - 암호화를 위해 bcrypt 패키지를 설치한다.
  - bcrypt는 c언어로 작성이 되어있기 때문에 node에서 원활히 사용하기 위해 npm install --global --production windows-build-tools를 설치한다.
  - app.js에 등록한다.
  - 패스워드 부분은 hash에 저장을하고, bcrypt.hash(req.body.password, 12)를 사용한다. 12는 높아질 수록 암호화가 강력해지지만, 그만큼 서버가 느려진다.

```bash
// back

npm install --global --production windows-build-tools

npm i bcrypt
```

- 3) exUser는 이메일의 중복을 막기 위해 db에서 findOne을 사용한다. 만일 exUser의 값이 들어있으면 401문구를 반환한다.
  - db 생성 시에도 방지하기 위해, models.user의 email에 unique: true를 추가한다.
  - db를 변경했으므로, db를 새로 생성해야 함.
  - back/app.js의 db.sequelize.sync();에 { force: true } 옵션을 추가하면, 새로 덮어씌워준다.
  - db.sequelize.sync({ force: true });
  - 배포시에는 forse: false로 변경하거나, 삭제한다.
- 4) db.User에 email, password, nickname을 create로 생성한다.
- 5) res에 HTTP 200을 보내고, 새롭게 만든 newUser 을 프론트에 넘겨준다.

```js
// back/app.js

const bcrypt = require('bcrypt');

app.post('/user', async (req, res, next) => {
  try {
    const hash = await bcrypt.hash(req.body.password, 12)

    // 이메일을 겹치지 않게 만든다.
    const exUser = await db.User.findOne({
      where: {
        email: req.body.email,
      }
    })
    if (exUser) { // 이미 회원가입이 되어있으면
      // return res.status(403).send('이미 회원가입이 되어있어요')
      return res.status(403).json({
        errorCode: 1,
        message: '이미 회원가입이 되어있어요'
      })
    }
    const newUser = await db.User.create({
      email: req.body.email,
      password: hash,
      nickname: req.body.nickname
    });
    res.status(201).json(newUser) // 성공적으로 생성했다.
    // 회원가입 후 바로 로그인하기
  } catch (err) {
    console.log(err);
    return next(err);
  }
})
```

- 6) front/pages/sighUp.vue의 onSubmitForm()을 수정한다.

```vue
// front/pages/sighUp.vue


<script>
  export default {
    ...,
    methods: {
      onSubmitForm() {
        if (this.$refs.form.validate()) {
          this.$store.dispatch('users/signUp', {
            email: this.email,
            nickname: this.nickname,
            password: this.password
    ...,
  }
</script>
```



## 5. 로그인 연결하기

### 1. passport 설치하기

- 1)로그인을 도와줄 패키지인 passport를 설치한다. 카카오를 등록할경우 passport-kakao 등을 설치하면 된다.

```bash
// back

npm i passport passport-local
```

- 2) passport 폴더를 생성한다.
- 3) app.js에 passport 패키지를 등록한다.
  - passport.initialize()는 요청, 응답을 조작해준다.(로그인 ,로그아웃)
  - passport.session() 는 메모리에 사용자 로그인 정보를 기록해준다.
- 4) 쿠키 패키지도 설치한다.
  - session()의 secret 부분과 cookie의 cookiesecret 을 일치시킨다.

```js
// back/app.js

const cookie = require('cookie-parser');
const passport = require('passport');

app.use(passport.initialize())
app.use(passport.session())

app.use(cookie('cookiesecret'))
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: 'cookiesecret',
}));
```

- 5) morgan 설치하기
  - 서버에서 요청을 받을때 요청 내용을 콘솔에 보여줄 패키지를 설치한다.

```bash
// back

npm i morgan
```

### 2. 로그인 동작 이해하기

- 1) 쿠키를 기반으로 사용자를 찾는다.
- 2) 서버에서 로그인 요청을 받으면 db에 있는지를 확인한다.
- 3) db에 있으면 세션에 쿠키랑 객체를 저장하고 프론트에 쿠키를 내려보낸다.

### 3. 로그인 구현하기 1

- 1) 이를 위해 passport에 local.js를 생성한다.
- 2) exUser는 db에 같은 email이 있는지 확인한다.
- 3) bcrypt.compare로 받은 password와 db로 찾은 exUser의 password를 비교한다.
- 4) done 함수는 (에러, 성공, 실패) 의 인자를 구성한다.
  - result가 true인 경우, done(null, exUser)로 성공까지 작성 후 반환한다.
  - result가 false인 경우 done(null, false, reason), 실패 까지 작성 후 반환한다.

```js
// back/passport/local.js

const passport = require('passport');
const bcrypt = require('bcrypt');
const { Strategy: LocalStrategy } = require('passport-local');
const db = require('../models');

module.exports = () => {
  passport.use(new LocalStrategy({
    usernameField: 'email', // req.body.email
    passwordField: 'password', // req.body.password
  }, async (email, password, done) => {

    try {
      // 검사부분
      const exUser = await db.User.findOne({ where: { email } });
      if (!exUser) {
        return done(null, false, { reason: '존재하지 않는 사용자입니다.' });
      }
      const result = await bcrypt.compare(password, exUser.password);
      if (result) {
        return done(null, exUser);
      } else {
        return done(null, false, { reason: '비밀번호가 틀립니다.' });
      }
    } catch (err) {
      console.error(err);
      return done(err);
    }
  }));
};
```

### 4. 로그인 구현하기 2

- local.js를 app.js에 등록한다.
- passport의 authenticate는 done함수와 비슷하게 (err, user, info)로 설정한다.
- req.login() 은 passport.initialize()으로부터 생성된 함수다.

```js
// back/app.js

// 로그인
app.post('/user/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) {
      console.log(err)
      return next(err);
    } 
    if (info) {
      return res.status(401).send(info.reason)
    }
    return req.login(user, async (err) => { // 세션마다 사용자 정보 저장
      if (err) {
        console.log(err);
        return next(err)
      }
      return res.json(user)
    });
  })(req, res, next);
})
```

- 여기서 req는 passport/idex.js로 부터 조작된 결과이다.
  - passport로 조작된 req는 프론트로 쿠키를 알아서 내려준다.
- user정보를 전부 저장을 하면 서버에 무리를 줄 수가 있다. serializeUse로 user.id만 저장을 한 뒤, 사용자 정보를 불러올 시에는 user.id를 사용해 deserializeUser에서 사용자정보 전부를 가져온다.

```js
// back/passport/index.js

const passport = require('passport');
const local = require('./local');
const db = require('../models');;

module.exports = () => {
  
  passport.serializeUser((user, done) => {
    return done(null, user.id)
  });

  passport.deserializeUser( async (id, done) => {
    try {
      const user = await db.User.findOne({ where: { id } });
      return done(null, user);
    } catch(err) {
      console.error(err);
      return done(err);
    }
  });
  local();
}
```

### 5. front 엣 LoinForm  수정하기

### 6. 회원가입 후 바로 로그인으로 연결하기

### 7. 쿠키 저장과  cors에러 발생

- 쿠키를 저장하고, 
- cedeintials 조건 추가하기