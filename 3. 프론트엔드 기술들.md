# 3. 프론트엔드 기술들

## 1. 팔로우/팔로딩 더미 데이터

### 1. store에 등록하기

- 기능구현을 확인하기 위해 state에 기본 데이터 입력하기

- 인자로 받은 userId를 이용한다.

  ```js
  // front/store/users.js
  
  export const state = () => ({
    me: null,
    followerList: [
      {
      id: 1,
      nickname: '1번'
      }, {
      id: 2,
      nickname: '2번'
      }, {
      id: 3,
      nickname: '3번'
      }
    ],
    followingList: [
      {
      id: 4,
      nickname: '4번'
      }, {
      id: 5,
      nickname: '5번'
      }, {
      id: 6,
      nickname: '6번'
      }
    ]
  });
  
  const totalFollowings = 8;
  const totalFollowers = 6;
  const limit = 3;
  
  export const mutations = {
    ...,
      
    addFollower(state, payload) {
      state.followerList.push(payload)
    },
    addFollowing(state, payload) {
      state.followingList.push(payload)
    },
    removeFollower(state, payload) {
      const targetIndex = state.followerList.findIndex(v => v.id === payload.userId)
      state.followerList.splice(targetIndex, 1)
    },
    removeFollowing(state, payload) {
      const targetIndex = state.followingList.findIndex(v => v.id === payload.userId)
      state.followingList.splice(targetIndex, 1)
    },
  }
  
  export const actions = {
    ...,
  
    addFollowing({ commit }, payload) {
      commit('addFollowing', payload)
    },
    addFollower({ commit }, payload) {
      commit('addFollower', payload)
    },
    removeFollowing({ commit }, payload) {
      commit('removeFollowing', payload)
    },
    removeFollower({ commit }, payload) {
      commit('removeFollower', payload)
    },
  }
  ```

### 2. FollowListForm 수정하기

- following과 follower는 같은 모양을 사용한다. 
- 따라서, FollowList.vue를 두개를 만들필요는 없고, 데이터를 다른 데이터로 넘겨주면 된다.
- 삭제 버튼 또한 followerList에서 삭제를 하느냐, followerList에서 삭제를 하는가의 함수 차이므로, 함수 또한 profile에서 다르게 넘긴다.
- 받은 데이터와 제거함수는 props에 자세히 등록한다.
- v-cion을 @click할 경우, remove함수가 실행이 되고, user.id가 인자로 넘어간다.

```vue
// front/pages/profile.vue

<template>
  <div>
    <v-container>
      ...,
      <v-card>
        <v-container>
          <v-subheader>팔로잉</v-subheader>
          <follow-list :users="followingList" :remove="removeFollowing" />
        </v-container>
      </v-card>
        
      <v-card>
        <v-container>
          <v-subheader>팔로워</v-subheader>
          <follow-list :users="followerList" :remove="removeFollower" />
        </v-container>
      </v-card>
        
    </v-container>
  </div>
</template>

<script>
  import FollowList from '~/components/FollowList'

  export default {
    components: {
      FollowList,
    },
    ...,
    computed: {
      followerList() {
        return this.$store.state.users.followerList;
      },
      followingList() {
        return this.$store.state.users.followingList;
      },
    },
    methods: {
      ...,
      removeFollower(userId) {
        this.$store.dispatch('users/removeFollower', { userId })
      },
      removeFollowing(userId) {
        this.$store.dispatch('users/removeFollowing', { userId })
      },
    },
    middleware: 'authenticated'
  }
</script>
```

```vue
// front/components/FollowList.vue

<template>
  <v-list>
    <ul>
      <li  v-for="user in users" :key="user.id">
        <span>{{ user.nickname }}</span>
        <v-icon @click="remove(user.id)">mdi-minus-circle-outline</v-icon>
      </li>
    </ul>
  </v-list>
</template>

<script>
  export default {
    props: {
      users: {
        type: Array,
        required: true
      },
      remove: {
        type: Function,
        required: true
      }
    }
    
  }
</script>
```



## 2. Veux 미들웨어

### 1.  미들웨어란

- 미들웨어:   3계층 클라이언트/서버 구조에서 미들웨어가 존재한다. 웹 브라우저에서 데이터베이스로부터 데이터를 저장하거나 읽어올 수 있게 중간에 미들웨어가 존재하게 된다.
- 모든 미들웨어는 middleware/ 디렉토리에 있어야한다. 따라서, front/middleware 폴더를 생성한다.
- 미들웨어는 context의 첫 인자로 전달받습니다. (구조분해 가능)
- 로그인 한 사용자인지를 확인하기 위해, authenticated.js 를 생성한다.
- 로그인 안 한 사용자인지를 확인하기 위해, anonymous.js를 생성한다.
- 로그인을 하지 않은 상태이면 메인페이지로 보낸다.(authenticated.js )

```js
// front/middleware/authenicated.js

export default function ({ store, redirect }) {
  if (!store.state.users.me) {
    redirect('/');
  }
}
```

- 로그인한 사용지이면, 메인페이지로 보낸다.(anonymous.js)

```js
// front/middleware/anonymous.js

export default function ({ store, redirect }) {
  if (store.state.users.me) {
    redirect('/');
  }
}
```

### 2. 미들웨어 사용하기

- 로그인한 사용자는 회원가입페이지를 클릭할 경우 메인페이지로 이동시킨다. 
- 즉, 로그인을 하지 않은 anonymous 만 들어올 수 있게 만든다.
- signup에 middleware로 anonymous 를 등록한다.

```vue
// front/posts/signup.vue

<script>
  export default {
    ...,
    middleware: 'anonymous'
  }
</script>
```

- 로그인을 하지 않은 사용자는 프로필페이지를 클릭할 경우 메인페이지로 이동시킨다. 
- 즉, 로그인을 한 authenticated만 들어올 수 있게 만든다.
- profile에 middleware로 authenticated를 등록한다.

```vue
// front/posts/profile.vue

<script>
  import FollowList from '~/components/FollowList'

  export default {
    ...,
    middleware: 'authenticated'
  }
</script>
```

### 3. 회원가입페이지에서 로그인을 할 경우 메인페이지로 이동하지 않는다면?

- signup페이지에서 로그인 변화를 감지하지 못해 발생한 이슈다.
- 따라 watch를 통해 변화를 감지하게 설정한다. (value에 me의 정보가 들어있다.)

```vue
// front/posts/signup.vue

<script>
  export default {
    ...
    watch: {
      me(value, oldValue) {
        // console.log(value, oldValue)
        if (value) {
          this.$router.push({
            path: '/'
          })
        }
      }
    },
    ...,
  }
</script>
```



## 3. 동적 라우팅

- 게시물 상세보기 구현
- /posts/1, /posts/2, /posts/3 ... 에서 뒤의 숫자만 변한다.
- front/pages/post를 생성한 뒤, _id 폴더를 생성하고, 그 폴더 안에 index.vue 파일을 생성한다.
- _id는 router의 params에 id값이 들어있다는 의미이다. 이 id는 computed에서 찾는다.
  - this.$route.params.id는 문자열이므로, parseInt를 통해 숫자로 변경시킨다.
- PostCard를 통해 해당 글만 보이게하기 위해 post만 넘긴다.

```vue
// front/posts/post/_id/index.vue

<template>
  <v-container v-if="post">
    <post-card :post="post" />
  </v-container>
  <div v-else>
    게시글이 존재하지 않는데요;; 다른 번호 검색 ㄱㄱ
  </div>
</template>

<script>
  import PostCard from '@/components/PostCard.vue';
  
  export default {
    components: {
      PostCard
    },
    computed: {
      post() {
        return this.$store.state.posts.mainPosts.find(v => v.id === parseInt(this.$route.params.id, 10))
      }
    },
  }
</script>
```



## 4. 인피니트 스크롤링 준비

### 1. 인피니트 스크롤링을 사용하는 이유

- 현재 index.vue에서 v-for을 통해 mainPosts를 post로 나눈 뒤, PostCard를 통해 연속적을 보여주고 있다.
- 하지만, 글이 많아져 글 전체를 로딩을 하게 되면 서버가 느려진다.
- 따라서, 예시로 10개를 로딩한 뒤, 스크롤이 일정 위치를 지나면 새로운 글 10개가 보이게 바꾼다.
  - 만일 10개 미만의 글이 로딩이 될 경우 멈추는 기능도 추가한다.
- 실무에서는 프론트엔드개발자는 전체 글의 갯수를 모르고, DB에서 길이를 구한다 하더라도 이는 DB에 큰 무리를 준다.



## 5. fetch와 인피니트 스크롤링 구현

### 1. store/posts에 등록하기

- state에 hasMorePost등록해서, hasMorePost이 true일 경우에만 글이 로딩이 되게한다.
- actions에 loadPosts를 추가하고, hasMorePost이 true일 경우에만 mutations의 loadPosts를 commit하게 한다.
- 전체 글의 갯수를 51로 한다. (totalPosts = 51;), 로딩할 글의 갯수는 10개로 한다.(limit = 10;)
- mutations의 loadPosts
  - diff = totalPosts - state.mainPosts.length;, 즉, diff는 아직 안 부른 글의 갯수를 의미한다.
  - diff > limit일 경우 limit 갯수만큼 글을 로딩하고, 반대의 경우는 diff 만큼 글을 로딩한다.
  - 만일 diff > limit가 아니면, 즉 로딩할 글의 갯수(10개)보다 적어지면 hasMorePost을 false로 변경하게 만든다.
  - 만든 fakePosts를 concat를 이용해서 mainPosts에 추가한다.

```js
export const state = () => ({
  mainPosts: [],
  hasMorePost: true
});

const totalPosts = 51;
const limit = 10;

export const mutations = {
  // ...,

  loadPosts(state) {    
    const diff = totalPosts - state.mainPosts.length;
    const fakePosts = Array(diff > limit ? limit : diff).fill().map(v => ({
      User: {
        id: Math.random().toString(),
        nickname: '남승현 리미트'
      },
      content: 'ㅎㅇ',
      Comments: [],
      Images: [],
      Video: [],
    }));
    state.mainPosts = state.mainPosts.concat(fakePosts)
    state.hasMorePost = diff > limit
  }
};

export const actions = {
  // ...,

  loadPosts({ commit, state }) {
    if (state.hasMorePost) {
      commit('loadPosts');
    }
  }
}
```

- 쓰로톨링: 
- 실무에서는 인피니트 스크롤링은 주로 글의 마지막 ID를 사용해서 구현한다.

## 6. virtualized list 이해하기

## 7. 더보기 구현하기

## 8. 기타 라우트 구현하기

