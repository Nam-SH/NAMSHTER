# 5. 기능 구현하기

## 0. 들어가기 전...

### 1) vue파일을 3개로 나누기

- vue파일을 template 전용으로하고, script와 style을 외부에서 불러 올 수 있다.
- 문서: [https://kr.vuejs.org/v2/guide/single-file-components.html#%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C](https://kr.vuejs.org/v2/guide/single-file-components.html#관심사의-분리는-무엇입니까)

```vue
// 사용예제

<template>
  <div>이 곳은 사전에 컴파일 됩니다.</div>
</template>
<script src="./my-component.js"></script>
<style src="./my-component.css"></style>
```

### 2) 만일 서버를 바꾸고 싶다면? (프론트)

- nuxt 설정을 관리하는 nuxt.config.js에서 server/ port를 추가(변경)한다.

```js
// front/nuxt.config.js

module.exports = {
  server: {
    port: 3081,
  }
}
```



## 1. 새로고침 후에도 로그인 유지하기

### 1) 서버에만 존재하는 유저정보를 프론트로 계속 가져오기

- req.user을 사용하면 되지만, password가 들어있다.
- 이것은 백엔드의 passport의 deserialzer로 인해 생긴 것이다. 따라서 back/passport/index.js 의 deserializeUser에서 attributes 를 설정해서, id와 nickname만 받게 한다.

```js
// back/passport/index.js

module.exports = () => {
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await db.User.findOne({
        where: { id },
        attributes: ['id', 'nickname'],
        include: [{
          model: db.Post,
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followings',
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followers',
          attributes: ['id'],
        }],
      });
      return done(null, user);
    } 
    catch (err) {
      console.error(err);
      return done('deserializeUser :::', err);
    }
  });
  local();
};
```

- 프론트에서 내 사용자 정보를 가져오는 actions를 작성한다. (muatons 은 setMe() 를 재사용 한다.)

```js
// front/store/users.js

export const actions = {
  // 사용자정보 가져오기
  async loadUser({ commit }) {
    try {
      const res = await this.$axios.get('/user', { 
        withCredentials: true,
      });
      commit('setMe', res.data)
    }
    catch (err) {
      console.error('loadUser :::', err);
    }
  },
```

- nuxtServerInit 액션
  - 만약 store에 `nuxtServerInit`가 정의되면, nuxt.js는 서버사이드에서 context와 함께 이 함수를 호출한다. 이는 서버에서 받은 데이터를 클라이언트로 직접 전달할 때 유용하다.
  - 예를 들어, 서버에서 세션을 가지고 있다면 `req.session.user`로 접근이 가능하다.
  - 모듈 모드를 사용한다면 최상위 모듈(`store/index.js`)에서만 이 함수가 호출된다.
  - 여기서는 해당 함수를 users에 있는 loadUser actions를 실행시키는 것으로만 한다.

```js
// front/store/index.js

export const actions = {
  nuxtServerInit({ commit, dispatch, state }, { req }) {
    return dispatch('users/loadUser');
  },
};
```



## 2. 모든 게시글 가져오기

### 1) back 에 라우트 정의하기

- Post에 유저정보, 좋아요, 리트윗을 담아서 보낸다.
- offset으로 초깃값을 지정하고, limit로 불러올 값을 지정한다.
  - offset 0, limit 10 => offset 10, limit 10 => offset 20, limit 10 => offset 30, limit 10
- offset, limit을 활용한 인피니트 스크롤링은 실무에서는 사용하지 않는다. lastId 방식은 나중에 구현할 예정이다.

```js
// back/routes/posts.js

router.get('/', async (req, res, next) => {
  try {
    const posts = await db.Post.findAll({
      include: [
        {
          model: db.User,
          attributes: ['id', 'nickname']
        }, {
          model: db.Image,
        }, {
          model: db.User,
          as: 'Likers',
          attributes: ['id']
        }, {
          model: db.Post,
          as: "Retweet",
          include: [
            {
              model: db.User,
              attributes: ['id', 'nickname']
            }
          ]
        }],
      order: [['createdAt', 'DESC']],
      offset: parseInt(req.query.offset, 10) || 0,
      limit: parseInt(req.query.limit, 10) || 10,
    });
    res.json(posts)
  }
  catch (err) {
    console.error(err)
    next(err)
  }
});
```

### 2) front에서 store 게시글 가져오기 만들기

- state에 있는 mainPosts의 길이를 offset으로 지정한 다음 쿼리스트링을 이용해서 요청에 함께 보낸다.

```js
// front/store/posts.js


export const state = () => ({
  mainPosts: [],
  hasMorePost: true,
});

export const mutations = {
  loadPosts(state, payload) {
    if (payload.reset) {
      state.mainPosts = payload.data  
    }
    else {
      state.mainPosts = state.mainPosts.concat(payload.data)
    }
    state.hasMorePost =  payload.data.length === 10;
  },
}

export const actions = {
  async loadPosts({ commit, state }, payload) {
    if (state.hasMorePost) {
      try {
        const res = await this.$axios.get(`/posts?offset=${state.mainPosts.length}&limit=10`)
        commit('loadPosts', res.data);
      }
      catch {
        console.error('loadPosts :::', loadPosts)
      }
    }
  },
 }
```



## 3. 닉네임 수정 구현하기



## 4. 댓글 구현하기

### 1) 모든 댓글 가져오기

- 프론트에서 postId를 넘겨 받는다. (req.params.id 에 들어있다.)
- 해당 postId 로 db.Post에서 해당 글의 존재 유무를 파악한다.
- 글이 존재할 경우 db.Comment 에서 postId를 가진 댓글들을 findAll 로 전부 찾은 뒤(where),  댓글에 유저정보를 담고, 시간 오름차순으로 정렬(order)한 뒤 프론트로 보낸다.

```js
// back/routes/post.js

// 댓글조회
router.get('/:id/comments', async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
      
    const comments = await db.Comment.findAll({
      where: {
        PostId: req.params.id,
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname'],
      }],
      order: [['createdAt', 'ASC'],],
    });
    res.json(comments);
  }
  catch (err) {
    console.error('GET /:id/comments :::', err);
    next(err);
  }
});
```

### 2) 댓글 추가하기

- 댓글 하나 추가는 addComment, 여러개의 추가는 addComments를 사용한다.
- 글이 없으면 404에러, 있으면 db.Comment에 create로 새로 만들어준다.(newComment)
- newComment에 유저정보를 넣어서 프론트에 보내준다.

```js
// back/routes/post.js

// 댓글작성
router.post('/:id/comment', isLoggedIn, async (req, res, next) => { // POST /post/:id/comment
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
    const newComment = await db.Comment.create({
      // postId, UserId는 associate의 관계 정의로 인해 자동으로 추가되어 있다.
      PostId: post.id,
      UserId: req.user.id,
      content: req.body.content,
    });
    // 프론트로 보낼 정보를 만든다.
    const comment = await db.Comment.findOne({
      where: {
        id: newComment.id
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname']
      }]
    });
    return res.json(comment);
  }
  catch (err) {
    console.error('POST/:id/comment :::', err)
    next(err)
  }
})
```

- 프론트의 store를 작성한다. mainPosts에 해당 글을 찾아서, Comments의 앞부분에 넣어준다.(unshift)

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  addComment(state, payload) {
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.PostId);
    state.mainPosts[targetIndex].Comments.unshift(payload)
  },
}

export const actions = {
  addComment({ commit }, payload ) {   
    this.$axios.post(`/post/${payload.postId}/comment`, {
      content: payload.content
    }, { 
      withCredentials: true 
    })
    .then((res) => {
      commit('addComment', res.data)
    })
    .catch((err) => {
      console.error('addComment:::', err)
    })
  },
}
```

### 3) 댓글 삭제하기 (숙제)

```
// back/routes/post.js


```

```
// front/store/posts.js


```

### 4) 댓글 수정하기 (숙제)

```js
// back/routes/post.js


```

```js
// front/store/posts.js


```



## 5. 게시글 상세보기 (숙제)

### 1) 



## 6. 게시글 삭제하기

- db에서 해당 글을 찾는다. 찾는 글이 없으면 404에러를 내려보낸다.
- 해당 글이 존재하면 db를 삭제하는 destroy 요청을 보낸다.

```js
// back/routes/post.js

router.delete('/:id', isLoggedIn, async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } })
    if (!post) {
      return res.status(400).send('포스트가 존재하지 않습니다.');
    }
    await db.Post.destroy({
      where: {
        id: req.params.id
      }
    });
    return res.send('삭제가 잘 됐어요...ㅎ')
  }
  catch (err) {
    console.error(err)
    next('delete(/:id) :::', err)
  }
})
```

- 프론트에서 /post로 DELETE요청을 보낸다.
- 프론트에서 delete를 보낼 때, 두번째 칸의 인자는 쓰지 않는다.

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  removeMainPost(state, payload) {
    // 지울 targetId와 같은 id를 mainPosts에서 찾는다.
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.postId);
    state.mainPosts.splice(targetIndex, 1);
  },
};

export const actions = {
  remove({ commit }, payload) {
    this.$axios.delete(`/post/${payload.postId}`, {
      withCredentials: true
    })
    .then((res) => {
      commit('removeMainPost', res.data)
    })
    .catch((err) => {
      console.error('remove:::', err)
    })
  },
};
```



## 7. 이미지 게시글 작성 시 보내주기

- 이미지를 첨부 후 글을 작성한 경우, 글과 함께 이미지의 이름을 저장한 imagePaths를 image로 설정한 뒤 같이 넘긴다.
- 서버에서는 이미지가 하나인 경우와, 여러 개인 경우를 나눠서 확인한다.
- 이미지가 여러개 인 경우 모든 작업이 끝나고 다음으로 넘어가는 것을 확실히 하기 위해 Promise.all 을 사용한다. (하나인 경우 req.body.image에 들어있다.)
- 생성된 newPost에 이지미 db를 추가해서 넘긴다.

```js
// back/routes/post.js

router.post('/', isLoggedIn, async (req, res, next) => { // POST /post
  try {
    const hashtags = req.body.content.match(/#[^\s#]+/g);
    const newPost = await db.Post.create({
      content: req.body.content,
      UserId: req.user.id,
    });
    if (hashtags) {
      const result = await Promise.all(hashtags.map(tag => db.Hashtag.findOrCreate({
        where: { name: tag.slice(1).toLowerCase() },
      })));
      await newPost.addHashtags(result.map(r => r[0]));
    }
    if (req.body.image) {
      // 여러개 경우
      if (Array.isArray(req.body.image)) {
        await Promise.all(req.body.image.map((image) => {
          return db.Image.create({ src: image, PostId: newPost.id });
        }));
      } 
      else { // 하나인 경우
        await db.Image.create({ src: req.body.image, PostId: newPost.id });
      };
    }
    const fullPost = await db.Post.findOne({
      where: { id: newPost.id },
      include: [{
        // 요청을 받으면 프론트에 User: { id:!, nickname: "남승현" } 형식이 추가된다.
        model: db.User,
        attributes: ['id', 'nickname'],
      }, {
        model: db.Image,
      }, {
        model: db.User,
        as: 'Likers',
        attributes: ['id'],
      }],
    });
    return res.json(fullPost);
  } 
  catch (err) {
    console.error('/post :::', err);
    next(err);
  }
});
```

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
  imagePaths: [],
});

export const mutations = {
  addMainPost(state, payload) {
    state.mainPosts.unshift(payload);
    state.imagePaths = [];
  },
};

export const actions = {
  add({ commit, state }, payload ) {
    // 서버에 게시글 등록 요청 보냄
    this.$axios.post('/post', 
      { content : payload.content, 
        image : state.imagePaths },
      { 
        withCredentials: true 
    })
    .then((res) => {
      commit('addMainPost', res.data)
    })
    .catch((err) => {
      console.error('add:::', err)
    })
  },
}
```



## 8.  이미지 carousel 로 보여주기

### 1)  과정

- pages/index.vue 에서 PostCard.vue 컴포넌트로 post(v-for="post in mainPosts") 를 보낸다.
- PostCard 에서는 리트윗 했는지와 안 했는지에 따라 글귀를 보여주고, 내용을 표시하기 위해 받은 post를 다시 PostContent.vue 로 보낸다.
- PostContent 에서는 이미지 부분(post.Image)을 PostImages로 보내고, content는 보여준다.
- PostImages 에서 이미지 1개, 2개, 3개 이상인 경우로 나눠서 보내주고, 이미지를 클릭 했을 경우, ImageZoom.vue로 받은 image를 넘겨준다.
- ImageZoom 에서는 받은 image를 캐로제로 보여준다.

### 2)  front/PostImages 

- v-img
  - `contain`: 칸에 이미지가 딱 맞게 조정되어서 들어간다.
  - `cover`: 남는 공간이 없이 이미지를 채운다.(이미지가 짤릴 수 있다.)
  - `aspect-ratio="2"`: 가로: 세로 = 2: 1
- 이미지가 없는 경우 => post.Images 를 빈 배열로 받은 경우, 그 길이를 구하고, 0이면 보여주지 않는다.
- 이미지가 하나인 경우 => 가운데에 표시한다.
- 이미지가 두개인 경우 => div로 `display: flex` 스타일을 넣고, 각각의 사진에 `flex: 1` 스타일을 넣어 div개 2등분이 되게 해서 이미지를 보여준다.
- 이미지가 세개인경우 => 처음 이미지만 보여주고, 나머지는 `...`으로 해서 보여준다.
- 이미지 또는 더보기 버튼을 클릭했을 경우, `zoomImages()` 메서드를 이용해서, 캐로제를 활성할 것인지에 대한 값인 `imageZoomed` 를 true로 바꿔준다.
- ImageZoom.vue 에 `imageZoomed`를 false로 변경시킬 `closeModal()` 메서드를 넘긴다.

### 3)  front/ImageZoom

- front/PostImages 로 받은 이미지(images) 와 캐로제를 종료시킬 함수(closeModal) 을 props에 등록한다.
- v-for을 이용해 images에 있는 것을 캐로제에 넣어준다.
- 이미지는 `:src="`http://localhost:3085/${img.src}`"` 처럼 db에 있는 그림을 가져온다.

## 

## 9. 리트윗 구현하기

## 10. 좋아요 구현하기

## 11. 팔로우, 팔로워 구현하기

## 12. 로그인 시 팔로우, 팔로워, 게시물 수 구현하기

## 13. lastId를 활용해 인피니티 스크롤 구현하기

## 14. 특정 유저의 글 전부 가져오기

## 15. 해시태그 구현하기

## 16. 검색기능 추가하기



