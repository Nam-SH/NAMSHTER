# 5. 기능 구현하기

## 0. 들어가기 전...

### 1) vue파일을 3개로 나누기

- vue파일을 template 전용으로하고, script와 style을 외부에서 불러 올 수 있다.
- 문서: [https://kr.vuejs.org/v2/guide/single-file-components.html#%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C](https://kr.vuejs.org/v2/guide/single-file-components.html#관심사의-분리는-무엇입니까)

```vue
// 사용예제

<template>
  <div>이 곳은 사전에 컴파일 됩니다.</div>
</template>
<script src="./my-component.js"></script>
<style src="./my-component.css"></style>
```

### 2) 만일 서버를 바꾸고 싶다면? (프론트)

- nuxt 설정을 관리하는 nuxt.config.js에서 server/ port를 추가(변경)한다.

```js
// front/nuxt.config.js

module.exports = {
  server: {
    port: 3081,
  }
}
```

### 3) Nuxt 에서 axios 사용

- `nuxt.config.js` 의 modules에 등록한다.
- browserBaseURL 은 클라이언트에서 axios 요청을 보낼 때 작성한다.
- BaseURL 은 서버에서 axios 요청을 보낼 때 작성한다.
  - browserBaseURL, BaseURL 모두 백엔드 주소를 입력해야 한다.
- Htttps: false
  - 만일 인증서를 받았다면 true로 변경한다.

```js
// font/nuxt.config.js

module.exports = {
  modules: [
    '@nuxtjs/axios',
  ],
  axios: {
    browserBaseURL: 'http://localhost:3085',
    baseURL: 'http://localhost:3085',
    https: false
  }, 
}
```

- nuxt.config.js 에 기본 주소를 등록했다면, front/store의 posts.js, users.js에 작성한 백엔드 주소를 지워도 된다.
  -  `this.$axios.post('/http://localhost:3085/post', { data })` => `this.$axios.post('/post', { data })`

### 4) 비동기 data()를 동기로 사용하고 싶다면?

- 컴포넌트 데이타를 세팅하기 전에 비동기 처리를 할 수 있는 asyncData() 가 있다.
- `asyncData`는 구성 요소를 로드하기 전에 항상 호출된다. (페이지 구성요소 만). 
- 서버 측에서 호출하거나 해당 경로를 탐색하기 전에 호출 할 수 있다. 
- `asyncData`의 결과는 데이터와 병합됩니다.



## 1. 새로고침 후에도 로그인 유지하기

### 1) 서버에만 존재하는 유저정보를 프론트로 계속 가져오기

- req.user을 사용하면 되지만, password가 들어있다.
- 이것은 백엔드의 passport의 deserialzer로 인해 생긴 것이다. 따라서 back/passport/index.js 의 deserializeUser에서 attributes 를 설정해서, id와 nickname만 받게 한다.

```js
// back/passport/index.js

module.exports = () => {
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await db.User.findOne({
        where: { id },
        attributes: ['id', 'nickname'],
        include: [{
          model: db.Post,
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followings',
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followers',
          attributes: ['id'],
        }],
      });
      return done(null, user);
    } 
    catch (err) {
      console.error(err);
      return done('deserializeUser :::', err);
    }
  });
  local();
};
```

- 프론트에서 내 사용자 정보를 가져오는 actions를 작성한다. (muatons 은 setMe() 를 재사용 한다.)

```js
// front/store/users.js

export const actions = {
  // 사용자정보 가져오기
  async loadUser({ commit }) {
    try {
      const res = await this.$axios.get('/user', { 
        withCredentials: true,
      });
      commit('setMe', res.data)
    }
    catch (err) {
      console.error('loadUser :::', err);
    }
  },
```

- nuxtServerInit 액션
  - 만약 store에 `nuxtServerInit`가 정의되면, nuxt.js는 서버사이드에서 context와 함께 이 함수를 호출한다. 이는 서버에서 받은 데이터를 클라이언트로 직접 전달할 때 유용하다.
  - 예를 들어, 서버에서 세션을 가지고 있다면 `req.session.user`로 접근이 가능하다.
  - 모듈 모드를 사용한다면 최상위 모듈(`store/index.js`)에서만 이 함수가 호출된다.
  - 여기서는 해당 함수를 users에 있는 loadUser actions를 실행시키는 것으로만 한다.

```js
// front/store/index.js

export const actions = {
  nuxtServerInit({ commit, dispatch, state }, { req }) {
    return dispatch('users/loadUser');
  },
};
```



## 2. 모든 게시글 가져오기

### 1) back 에 라우트 정의하기

- Post에 유저정보, 좋아요, 리트윗을 담아서 보낸다.
- offset으로 초깃값을 지정하고, limit로 불러올 값을 지정한다.
  - offset 0, limit 10 => offset 10, limit 10 => offset 20, limit 10 => offset 30, limit 10
- offset, limit을 활용한 인피니트 스크롤링은 실무에서는 사용하지 않는다. lastId 방식은 나중에 구현할 예정이다.

```js
// back/routes/posts.js

router.get('/', async (req, res, next) => {
  try {
    const posts = await db.Post.findAll({
      include: [
        {
          model: db.User,
          attributes: ['id', 'nickname']
        }, {
          model: db.Image,
        }, {
          model: db.User,
          as: 'Likers',
          attributes: ['id']
        }, {
          model: db.Post,
          as: "Retweet",
          include: [
            {
              model: db.User,
              attributes: ['id', 'nickname']
            }
          ]
        }],
      order: [['createdAt', 'DESC']],
      offset: parseInt(req.query.offset, 10) || 0,
      limit: parseInt(req.query.limit, 10) || 10,
    });
    res.json(posts)
  }
  catch (err) {
    console.error(err)
    next(err)
  }
});
```

### 2) front에서 store 게시글 가져오기 만들기

- state에 있는 mainPosts의 길이를 offset으로 지정한 다음 쿼리스트링을 이용해서 요청에 함께 보낸다.

```js
// front/store/posts.js


export const state = () => ({
  mainPosts: [],
  hasMorePost: true,
});

export const mutations = {
  loadPosts(state, payload) {
    if (payload.reset) {
      state.mainPosts = payload.data  
    }
    else {
      state.mainPosts = state.mainPosts.concat(payload.data)
    }
    state.hasMorePost =  payload.data.length === 10;
  },
}

export const actions = {
  async loadPosts({ commit, state }, payload) {
    if (state.hasMorePost) {
      try {
        const res = await this.$axios.get(`/posts?offset=${state.mainPosts.length}&limit=10`)
        commit('loadPosts', res.data);
      }
      catch {
        console.error('loadPosts :::', loadPosts)
      }
    }
  },
 }
```



## 3. 닉네임 수정 구현하기



## 4. 댓글 구현하기

### 1) 모든 댓글 가져오기

- 프론트에서 postId를 넘겨 받는다. (req.params.id 에 들어있다.)
- 해당 postId 로 db.Post에서 해당 글의 존재 유무를 파악한다.
- 글이 존재할 경우 db.Comment 에서 postId를 가진 댓글들을 findAll 로 전부 찾은 뒤(where),  댓글에 유저정보를 담고, 시간 오름차순으로 정렬(order)한 뒤 프론트로 보낸다.

```js
// back/routes/post.js

// 댓글조회
router.get('/:id/comments', async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
      
    const comments = await db.Comment.findAll({
      where: {
        PostId: req.params.id,
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname'],
      }],
      order: [['createdAt', 'ASC'],],
    });
    res.json(comments);
  }
  catch (err) {
    console.error('GET /:id/comments :::', err);
    next(err);
  }
});
```

### 2) 댓글 추가하기

- 댓글 하나 추가는 addComment, 여러개의 추가는 addComments를 사용한다.
- 글이 없으면 404에러, 있으면 db.Comment에 create로 새로 만들어준다.(newComment)
- newComment에 유저정보를 넣어서 프론트에 보내준다.

```js
// back/routes/post.js

// 댓글작성
router.post('/:id/comment', isLoggedIn, async (req, res, next) => { // POST /post/:id/comment
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
    const newComment = await db.Comment.create({
      // postId, UserId는 associate의 관계 정의로 인해 자동으로 추가되어 있다.
      PostId: post.id,
      UserId: req.user.id,
      content: req.body.content,
    });
    // 프론트로 보낼 정보를 만든다.
    const comment = await db.Comment.findOne({
      where: {
        id: newComment.id
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname']
      }]
    });
    return res.json(comment);
  }
  catch (err) {
    console.error('POST/:id/comment :::', err)
    next(err)
  }
})
```

- 프론트의 store를 작성한다. mainPosts에 해당 글을 찾아서, Comments의 앞부분에 넣어준다.(unshift)

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  addComment(state, payload) {
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.PostId);
    state.mainPosts[targetIndex].Comments.unshift(payload)
  },
}

export const actions = {
  addComment({ commit }, payload ) {   
    this.$axios.post(`/post/${payload.postId}/comment`, {
      content: payload.content
    }, { 
      withCredentials: true 
    })
    .then((res) => {
      commit('addComment', res.data)
    })
    .catch((err) => {
      console.error('addComment:::', err)
    })
  },
}
```

### 3) 댓글 삭제하기 (숙제)

```
// back/routes/post.js


```

```
// front/store/posts.js


```

### 4) 댓글 수정하기 (숙제)

```js
// back/routes/post.js


```

```js
// front/store/posts.js


```



## 5. 게시글 상세보기 (숙제)

### 1) 



## 6. 게시글 삭제하기

- db에서 해당 글을 찾는다. 찾는 글이 없으면 404에러를 내려보낸다.
- 해당 글이 존재하면 db를 삭제하는 destroy 요청을 보낸다.

```js
// back/routes/post.js

router.delete('/:id', isLoggedIn, async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } })
    if (!post) {
      return res.status(400).send('포스트가 존재하지 않습니다.');
    }
    await db.Post.destroy({
      where: {
        id: req.params.id
      }
    });
    return res.send('삭제가 잘 됐어요...ㅎ')
  }
  catch (err) {
    console.error(err)
    next('delete(/:id) :::', err)
  }
})
```

- 프론트에서 /post로 DELETE요청을 보낸다.
- 프론트에서 delete를 보낼 때, 두번째 칸의 인자는 쓰지 않는다.

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  removeMainPost(state, payload) {
    // 지울 targetId와 같은 id를 mainPosts에서 찾는다.
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.postId);
    state.mainPosts.splice(targetIndex, 1);
  },
};

export const actions = {
  remove({ commit }, payload) {
    this.$axios.delete(`/post/${payload.postId}`, {
      withCredentials: true
    })
    .then((res) => {
      commit('removeMainPost', res.data)
    })
    .catch((err) => {
      console.error('remove:::', err)
    })
  },
};
```



## 7. 이미지 게시글 작성 시 보내주기

- 이미지를 첨부 후 글을 작성한 경우, 글과 함께 이미지의 이름을 저장한 imagePaths를 image로 설정한 뒤 같이 넘긴다.
- 서버에서는 이미지가 하나인 경우와, 여러 개인 경우를 나눠서 확인한다.
- 이미지가 여러개 인 경우 모든 작업이 끝나고 다음으로 넘어가는 것을 확실히 하기 위해 Promise.all 을 사용한다. (하나인 경우 req.body.image에 들어있다.)
- 생성된 newPost에 이지미 db를 추가해서 넘긴다.

```js
// back/routes/post.js

router.post('/', isLoggedIn, async (req, res, next) => { // POST /post
  try {
    const hashtags = req.body.content.match(/#[^\s#]+/g);
    const newPost = await db.Post.create({
      content: req.body.content,
      UserId: req.user.id,
    });
    if (hashtags) {
      const result = await Promise.all(hashtags.map(tag => db.Hashtag.findOrCreate({
        where: { name: tag.slice(1).toLowerCase() },
      })));
      await newPost.addHashtags(result.map(r => r[0]));
    }
    // 이미지가 포함되어 있다면??
    if (req.body.image) {
      // 여러개 경우
      if (Array.isArray(req.body.image)) {
        await Promise.all(req.body.image.map((image) => {
          return db.Image.create({ src: image, PostId: newPost.id });
        }));
      } 
      else { // 하나인 경우
        await db.Image.create({ 
            src: req.body.image, 
            PostId: newPost.id 
        });
      };
    }
    
    const fullPost = await db.Post.findOne({
      where: { id: newPost.id },
      include: [{
        // 요청을 받으면 프론트에 User: { id:!, nickname: "남승현" } 형식이 추가된다.
        model: db.User,
        attributes: ['id', 'nickname'],
      }, {
        model: db.Image,
      }, {
        model: db.User,
        as: 'Likers',
        attributes: ['id'],
      }],
    });
    return res.json(fullPost);
  } 
  catch (err) {
    console.error('/post :::', err);
    next(err);
  }
});
```

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
  imagePaths: [],
});

export const mutations = {
  addMainPost(state, payload) {
    state.mainPosts.unshift(payload);
    state.imagePaths = [];
  },
};

export const actions = {
  add({ commit, state }, payload ) {
    // 서버에 게시글 등록 요청 보냄
    this.$axios.post('/post', 
      { content : payload.content, 
        image : state.imagePaths },
      { 
        withCredentials: true 
    })
    .then((res) => {
      commit('addMainPost', res.data)
    })
    .catch((err) => {
      console.error('add:::', err)
    })
  },
}
```



## 8.  이미지 carousel 로 보여주기

### 1)  과정

- pages/index.vue 에서 PostCard.vue 컴포넌트로 post(v-for="post in mainPosts") 를 보낸다.
- PostCard 에서는 리트윗 했는지와 안 했는지에 따라 글귀를 보여주고, 내용을 표시하기 위해 받은 post를 다시 PostContent.vue 로 보낸다.
- PostContent 에서는 이미지 부분(post.Image)을 PostImages로 보내고, content는 보여준다.
- PostImages 에서 이미지 1개, 2개, 3개 이상인 경우로 나눠서 보내주고, 이미지를 클릭 했을 경우, ImageZoom.vue로 받은 image를 넘겨준다.
- ImageZoom 에서는 받은 image를 캐로제로 보여준다.

### 2)  front/PostImages 

- v-img
  - `contain`: 칸에 이미지가 딱 맞게 조정되어서 들어간다.
  - `cover`: 남는 공간이 없이 이미지를 채운다.(이미지가 짤릴 수 있다.)
  - `aspect-ratio="2"`: 가로: 세로 = 2: 1
- 이미지가 없는 경우 => post.Images 를 빈 배열로 받은 경우, 그 길이를 구하고, 0이면 보여주지 않는다.
- 이미지가 하나인 경우 => 가운데에 표시한다.
- 이미지가 두개인 경우 => div로 `display: flex` 스타일을 넣고, 각각의 사진에 `flex: 1` 스타일을 넣어 div개 2등분이 되게 해서 이미지를 보여준다.
- 이미지가 세개인경우 => 처음 이미지만 보여주고, 나머지는 `...`으로 해서 보여준다.
- 이미지 또는 더보기 버튼을 클릭했을 경우, `zoomImages()` 메서드를 이용해서, 캐로제를 활성할 것인지에 대한 값인 `imageZoomed` 를 true로 바꿔준다.
- ImageZoom.vue 에 `imageZoomed`를 false로 변경시킬 `closeModal()` 메서드를 넘긴다.

```vue
// front/components/PostImages.vue

<template>
  <div v-if="images.length === 0"></div>
  <!-- 이미지가 1개인 경우 -->
  <div v-else-if="images.length === 1">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      @click="zoomImages"
    />
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>

  <!-- 이미지가 2개인 경우 -->
  <div v-else-if="images.length === 2" style="display: flex">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <v-img 
      :src="`http://localhost:3085/${images[1].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>
  
  <!-- 이미지가 3개인 경우 -->
  <div v-else style="display: flex">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <div style="flex: 1; align-items: center; justify-content: center; display: flex" @click="zoomImages">
      <div style="text-align: center">
        <v-icon>mdi-dots-horizontal</v-icon>
        <div>더 보기</div>
      </div>
    </div>
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>
</template>

<script>
  import ImageZoom from '@/components/ImageZoom.vue';

  export default {
    components: {
      ImageZoom
    },
    props: {
      images: {
        type: Array,
        required: true,
      }
    },
    data() {
      return {
        imageZoomed: false,
      }
    },
    methods: {
      closeModal() {
        this.imageZoomed = false;
      },
      zoomImages() {
        this.imageZoomed = true;
      }
    },
  };
</script>
```

### 3)  front/ImageZoom

- front/PostImages 로 받은 이미지(images) 와 캐로제를 종료시킬 함수(closeModal) 을 props에 등록한다.
- v-for을 이용해 images에 있는 것을 캐로제에 넣어준다.
- 이미지는 `:src="`http://localhost:3085/${img.src}`"` 처럼 db에 있는 그림을 가져온다.

```vue
// front/components/ImageZoom.vue

<template>
  <div id="image-zoom">
    <header>
      <h1>상세 이미지 </h1> <v-icon id="close-btn" @click="closeModal">mdi-close</v-icon>
    </header>
    <div id="carousel-wrapper">
      <v-carousel>
        <v-carousel-item v-for="img in images" :key="img.src">
          <v-sheet>
            <v-img max-height="500" contain :src="`http://localhost:3085/${img.src}`" />
          </v-sheet>
        </v-carousel-item>
      </v-carousel>
    </div>
  </div>
</template>

<script>
  export default {
    props: {
      images: {
        type: Array,
        required: true,
      },
      closeModal: {
        type: Function,
        required: true,
      },
    }
  }
</script>
```



## 9. 리트윗 구현하기

### 1) 요청 주소: `'/:id/retweet'`

### 2) db 생성

- 새로운 글을 생성하면 Post의 고유id가 생성되고, 해당 Post가 리트윗된 글이면, 새로운 글의 Post db는 원본Post의 id를 리트윗id 에 등록한다.
- 즉, Post와 Post 간의 관계가 만들어진다.
- db.Post.belongsTo(db.Post, { as: 설정할이름 })
  - Post 에 설정할이름Id 컬럼이 추가된다. (target의 id가 source로 들어간다.)

### 3) 리트윗 조건 설정

- 로그인 안 한 사용자의 리트윗 요청 무시
- 글이 없는 경우 리트윗 요청 무시
- 작성된 글의 사용자id가 나의 id와 같으면 리트윗 요청 무시
- 내가 한 리트윗 된 글인 경우 또는 내가 작성한 글인 경우 리트윗 요청 무시

### 4) router작성

- 조건을 설정하고, 검사가 끝나면 Post에 UserId와 RetweetId, content를 넘겨서 만든다. (retweet)
- 내가 작성한 글에 원본글이 표시가 되는 형식이다.

```js
// back/routes/post.js

// 리트윗 하기
router.post('/:id/retweet', isLoggedIn, async (req, res, next) => {
  try {
    // 1. 글이 없으면 리트윗 안 됨
    const post = await db.Post.findOne({
      where: { id: req.params.id, },
      include: [{
        model: db.Post,
        as: 'Retweet'
      }]
    })
    if (!post) {
      return res.status(404).send('글이 없는데요;;')
    }
      
    // 2. 글의 유저아이이가 내 id와 같으면 리트윗 하면 안 됨
    if (req.user.id === post.UserId || (post.Retweet && post.Retweet.UserId === req.user.id)) {
      return res.status(403).send('자신의 글을 리트윗할 수 없습니다.');
    }

    // 3. 리트윗 된 글이 또는 작성된 글이 내 글이면 리트윗하면 안 됨
    const retweetTargetId = post.RetweetId || post.id; // 리트윗한 했으면 그 원본 or 원본
    const exPost = await db.Post.findOne({
      where: {
        UserId: req.user.id,
        RetweetId: retweetTargetId,
      }
    })
    if (exPost) {
      return res.status(403).send('이미 리트윗했습니다요')
    }
    // 검사 끝~~

    const retweet = await db.Post.create({
      UserId: req.user.id,
      RetweetId: retweetTargetId, //
      content: '리트윗한 글만 보여줄꺼임~~',
    })
    const retweetWithPrevPost = await db.Post.findOne({
      where: { id: retweet.id },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname']
      }, {
        model:db.Post,
        as: 'Retweet',
        include: [{
          model: db.User,
          attributes: ['id', 'nickname'],
        }, {
          model: db.Image,
        }, {
          model: db.User,
          as: 'Likers',
          attributes: ['id']
        }]
      }]
    })
    res.json(retweetWithPrevPost);
  }
  catch (err) {
    console.error('/:id/retweet :::', err)
    next(err)
  }
});
```

### 5) store 작성

```js
// front/store/posts.js

export const mutations = {
  addMainPost(state, payload) {
    state.mainPosts.unshift(payload);
    state.imagePaths = [];
  },
}

export const actions = {
  retweet({ commit }, payload) {
    this.$axios.post(`/post/${payload.postId}/retweet`, {}, {
      withCredentials: true
    })
    .then((res) => {
      // res.data에는 리트윗한 나의 User id, nickname
      // 원본글의 Id와, 글 작성자의 User id, nickname, 글의 image 주소가 들어있다.
      commit('addMainPost', res.data)
    })
    .catch((err) => {
      console.error('retweet:::', err)
      // 작성한 에러메시지
      alert(err.response.data)
    })
  }
}
```



## 10. 좋아요 구현하기

### 1) 요청주소: `'/:id/like'` 

### 2) db 생성

- 한 사람이 여러 게시글에 좋아요 클릭할 수 있고, 하나의 게시글은 여러 사람의 좋아요를 받을 수 있다.
- `db.Post.belongsToMany(db.User, {  through: 'Like', as: 'Likers' })`
- `db.User.belongsToMany(db.Post, { through: 'Like', as: 'Liked' } )`



## 11. 팔로우, 팔로워 구현하기

### 1) 요청주소:  `'/:id/follow' `, ` '/:id/follower' `

### 2) db 생성: 

- 팔로잉, 팔로워는 User간의 N:M 관계이다.
- `db.User.belongsToMany(db.User, { through: 테이블이름 , as: follower(설정할id이름) foreignKey: followingId(참조할id)})`
  - 내가 나의 follower 를 가져온다면, 다른 유저의 followingId를 참조해서 가져오겠다는 뜻이다.
  - foreignKey는 as에 작성한 것과 반대의 개념으로 이해하면 된다.

### 3) 



## 12. 로그인 시 팔로우, 팔로워, 게시물 수 구현하기

## 13. lastId를 활용해 인피니티 스크롤 구현하기

## 14. 특정 유저의 글 전부 가져오기

## 15. 해시태그 구현하기

## 16. 검색기능 추가하기



