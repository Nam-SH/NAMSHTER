# 5. 기능 구현하기

## 

## 1. 새로고침 후에도 로그인 유지하기

### 1) 서버에만 존재하는 유저정보를 프론트로 계속 가져오기

- req.user을 사용하면 되지만, password가 들어있다.
- 이것은 백엔드의 passport의 deserialzer로 인해 생긴 것이다. 따라서 back/passport/index.js 의 deserializeUser에서 attributes 를 설정해서, id와 nickname만 받게 한다.

```js
// back/passport/index.js

module.exports = () => {
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await db.User.findOne({
        where: { id },
        attributes: ['id', 'nickname'],
        include: [{
          model: db.Post,
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followings',
          attributes: ['id'],
        }, {
          model: db.User,
          as: 'Followers',
          attributes: ['id'],
        }],
      });
      return done(null, user);
    } 
    catch (err) {
      console.error(err);
      return done('deserializeUser :::', err);
    }
  });
  local();
};
```

- 프론트에서 내 사용자 정보를 가져오는 actions를 작성한다. (muatons 은 setMe() 를 재사용 한다.)

```js
// front/store/users.js

export const actions = {
  // 사용자정보 가져오기
  async loadUser({ commit }) {
    try {
      const res = await this.$axios.get('/user', { 
        withCredentials: true,
      });
      commit('setMe', res.data)
    }
    catch (err) {
      console.error('loadUser :::', err);
    }
  },
```

- nuxtServerInit 액션
  - 만약 store에 `nuxtServerInit`가 정의되면, nuxt.js는 서버사이드에서 context와 함께 이 함수를 호출한다. 이는 서버에서 받은 데이터를 클라이언트로 직접 전달할 때 유용하다.
  - 예를 들어, 서버에서 세션을 가지고 있다면 `req.session.user`로 접근이 가능하다.
  - 모듈 모드를 사용한다면 최상위 모듈(`store/index.js`)에서만 이 함수가 호출된다.
  - 여기서는 해당 함수를 users에 있는 loadUser actions를 실행시키는 것으로만 한다.

```js
// front/store/index.js

export const actions = {
  nuxtServerInit({ commit, dispatch, state }, { req }) {
    return dispatch('users/loadUser');
  },
};
```



## 2. 모든 게시글 가져오기

### 1) back 에 라우트 정의하기

- Post에 유저정보, 좋아요, 리트윗을 담아서 보낸다.
- offset으로 초깃값을 지정하고, limit로 불러올 값을 지정한다.
  - offset 0, limit 10 => offset 10, limit 10 => offset 20, limit 10 => offset 30, limit 10
- offset, limit을 활용한 인피니트 스크롤링은 실무에서는 사용하지 않는다. lastId 방식은 나중에 구현할 예정이다.

```js
// back/routes/posts.js

router.get('/', async (req, res, next) => {
  try {
    const posts = await db.Post.findAll({
      include: [
        {
          model: db.User,
          attributes: ['id', 'nickname']
        }, {
          model: db.Image,
        }, {
          model: db.User,
          as: 'Likers',
          attributes: ['id']
        }, {
          model: db.Post,
          as: "Retweet",
          include: [
            {
              model: db.User,
              attributes: ['id', 'nickname']
            }
          ]
        }],
      order: [['createdAt', 'DESC']],
      offset: parseInt(req.query.offset, 10) || 0,
      limit: parseInt(req.query.limit, 10) || 10,
    });
    res.json(posts)
  }
  catch (err) {
    console.error(err)
    next(err)
  }
});
```

### 2) front에서 store 게시글 가져오기 만들기

- state에 있는 mainPosts의 길이를 offset으로 지정한 다음 쿼리스트링을 이용해서 요청에 함께 보낸다.

```js
// front/store/posts.js


export const state = () => ({
  mainPosts: [],
  hasMorePost: true,
});

export const mutations = {
  loadPosts(state, payload) {
    if (payload.reset) {
      state.mainPosts = payload.data  
    }
    else {
      state.mainPosts = state.mainPosts.concat(payload.data)
    }
    state.hasMorePost =  payload.data.length === 10;
  },
}

export const actions = {
  async loadPosts({ commit, state }, payload) {
    if (state.hasMorePost) {
      try {
        const res = await this.$axios.get(`/posts?offset=${state.mainPosts.length}&limit=10`)
        commit('loadPosts', res.data);
      }
      catch {
        console.error('loadPosts :::', loadPosts)
      }
    }
  },
 }
```



## 3. 닉네임 수정 구현하기

#### 1)  부분 수정이므로 patch 사용

- 수정은 db.User에서 update로 변경한다.
  - update({ 수정할 값 }, { 내가 수정하고자하는 db 위치 }) 의 순서로 작성한다.
- 프론트에 닉네임을 보내준다.

```js
// front/route/user.js

router.patch('/nickname', isLoggedIn, async (req, res, next) => {
  try {
    await db.User.update({
      nickname: req.body.nickname,
    }, {
      where: { id: req.user.id, }
    });
    res.send(req.body.nickname);
  }
  catch (err) {
    console.error('/nickname :::', err)
    next(err)
  }
});
```

- axios로 patch 요청을 nickname을 담아서 보낸다.
- mutations에서 내가 가진 닉네임 값을 새로운 닉네임으로 변경한다.

```js
// front/store/users.js

export const state = () => ({
  me: null,
});

export const mutations = {
  changeNickname(state, payload) {
    state.me.nickname = payload
  },
};

export const actions = {
  changeNickname({ commit }, payload) {
    this.$axios.patch('/user/nickname', { nickname: payload.nickname }, {
      withCredentials: true,
    })
    .then((res) => {
      commit('changeNickname', res.data)
    })
    .catch((err) => {
      console.error('changeNickname :::', err)
    })
  },
};
```

```vue
// front/pages/profile.vue

<template>
  <div>
    <v-container>
      <v-card style="margin-bottom: 20px">
        <v-container>
          <v-subheader>내 프로필</v-subheader>    
          <v-form v-model="valid" @submit.prevent="onChangeNickname">
            <v-text-field 
              label="닉네임" 
              required 
              v-model="nickname"
              :rules="nicknameRules"
            />
            <v-btn dark color="blue" type="submit">수정</v-btn>
    ...
</template>

<script>
  export default {
    data() {
      return {
        valid: false,
        nickname: '',
        nicknameRules: [
          v => !!v || '닉네임을 입력하시옵소서'
        ]
      }
    },
    methods: {
      onChangeNickname() {
        this.$store.dispatch('users/changeNickname', {
          nickname: this.nickname
        })
        .then(() => {
          this.nickname = ''
        })
        .catch((err) => {
          console.error('onChangeNickname :::', err)
        })
      },
    },
    middleware: 'authenticated'
  }
</script>
```



## 4. 댓글 구현하기

### 1) 모든 댓글 가져오기

- 프론트에서 postId를 넘겨 받는다. (req.params.id 에 들어있다.)
- 해당 postId 로 db.Post에서 해당 글의 존재 유무를 파악한다.
- 글이 존재할 경우 db.Comment 에서 postId를 가진 댓글들을 findAll 로 전부 찾은 뒤(where),  댓글에 유저정보를 담고, 시간 오름차순으로 정렬(order)한 뒤 프론트로 보낸다.

```js
// back/routes/post.js

// 댓글조회
router.get('/:id/comments', async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
      
    const comments = await db.Comment.findAll({
      where: {
        PostId: req.params.id,
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname'],
      }],
      order: [['createdAt', 'ASC'],],
    });
    res.json(comments);
  }
  catch (err) {
    console.error('GET /:id/comments :::', err);
    next(err);
  }
});
```

### 2) 댓글 추가하기

- 댓글 하나 추가는 addComment, 여러개의 추가는 addComments를 사용한다.
- 글이 없으면 404에러, 있으면 db.Comment에 create로 새로 만들어준다.(newComment)
- newComment에 유저정보를 넣어서 프론트에 보내준다.

```js
// back/routes/post.js

// 댓글작성
router.post('/:id/comment', isLoggedIn, async (req, res, next) => { // POST /post/:id/comment
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } });
    if (!post) {
      return res.status(404).send('포스트가 존재하지 않습니다.');
    }
    const newComment = await db.Comment.create({
      // postId, UserId는 associate의 관계 정의로 인해 자동으로 추가되어 있다.
      PostId: post.id,
      UserId: req.user.id,
      content: req.body.content,
    });
    // 프론트로 보낼 정보를 만든다.
    const comment = await db.Comment.findOne({
      where: {
        id: newComment.id
      },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname']
      }]
    });
    return res.json(comment);
  }
  catch (err) {
    console.error('POST/:id/comment :::', err)
    next(err)
  }
})
```

- 프론트의 store를 작성한다. mainPosts에 해당 글을 찾아서, Comments의 앞부분에 넣어준다.(unshift)

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  addComment(state, payload) {
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.PostId);
    state.mainPosts[targetIndex].Comments.unshift(payload)
  },
}

export const actions = {
  addComment({ commit }, payload ) {   
    this.$axios.post(`/post/${payload.postId}/comment`, {
      content: payload.content
    }, { 
      withCredentials: true 
    })
    .then((res) => {
      commit('addComment', res.data)
    })
    .catch((err) => {
      console.error('addComment:::', err)
    })
  },
}
```

### 3) 댓글 삭제하기 (숙제)

```
// back/routes/post.js


```

```
// front/store/posts.js


```

### 4) 댓글 수정하기 (숙제)

```js
// back/routes/post.js


```

```js
// front/store/posts.js


```



## 5. 게시글 상세보기 (숙제)

### 1) 



## 6. 게시글 삭제하기

- db에서 해당 글을 찾는다. 찾는 글이 없으면 404에러를 내려보낸다.
- 해당 글이 존재하면 db를 삭제하는 destroy 요청을 보낸다.

```js
// back/routes/post.js

router.delete('/:id', isLoggedIn, async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id } })
    if (!post) {
      return res.status(400).send('포스트가 존재하지 않습니다.');
    }
    await db.Post.destroy({
      where: {
        id: req.params.id
      }
    });
    return res.send('삭제가 잘 됐어요...ㅎ')
  }
  catch (err) {
    console.error(err)
    next('delete(/:id) :::', err)
  }
})
```

- 프론트에서 /post로 DELETE요청을 보낸다.
- 프론트에서 delete를 보낼 때, 두번째 칸의 인자는 쓰지 않는다.

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
});

export const mutations = {
  removeMainPost(state, payload) {
    // 지울 targetId와 같은 id를 mainPosts에서 찾는다.
    const targetIndex = state.mainPosts.findIndex(v => v.id === payload.postId);
    state.mainPosts.splice(targetIndex, 1);
  },
};

export const actions = {
  remove({ commit }, payload) {
    this.$axios.delete(`/post/${payload.postId}`, {
      withCredentials: true
    })
    .then((res) => {
      commit('removeMainPost', res.data)
    })
    .catch((err) => {
      console.error('remove:::', err)
    })
  },
};
```



## 7. 이미지 게시글 작성 시 보내주기

- 이미지를 첨부 후 글을 작성한 경우, 글과 함께 이미지의 이름을 저장한 imagePaths를 image로 설정한 뒤 같이 넘긴다.
- 서버에서는 이미지가 하나인 경우와, 여러 개인 경우를 나눠서 확인한다.
- 이미지가 여러개 인 경우 모든 작업이 끝나고 다음으로 넘어가는 것을 확실히 하기 위해 Promise.all 을 사용한다. (하나인 경우 req.body.image에 들어있다.)
- 생성된 newPost에 이지미 db를 추가해서 넘긴다.

```js
// back/routes/post.js

router.post('/', isLoggedIn, async (req, res, next) => { // POST /post
  try {
    const hashtags = req.body.content.match(/#[^\s#]+/g);
    const newPost = await db.Post.create({
      content: req.body.content,
      UserId: req.user.id,
    });
    if (hashtags) {
      const result = await Promise.all(hashtags.map(tag => db.Hashtag.findOrCreate({
        where: { name: tag.slice(1).toLowerCase() },
      })));
      await newPost.addHashtags(result.map(r => r[0]));
    }
    // 이미지가 포함되어 있다면??
    if (req.body.image) {
      // 여러개 경우
      if (Array.isArray(req.body.image)) {
        await Promise.all(req.body.image.map((image) => {
          return db.Image.create({ src: image, PostId: newPost.id });
        }));
      } 
      else { // 하나인 경우
        await db.Image.create({ 
            src: req.body.image, 
            PostId: newPost.id 
        });
      };
    }
    
    const fullPost = await db.Post.findOne({
      where: { id: newPost.id },
      include: [{
        // 요청을 받으면 프론트에 User: { id:!, nickname: "남승현" } 형식이 추가된다.
        model: db.User,
        attributes: ['id', 'nickname'],
      }, {
        model: db.Image,
      }, {
        model: db.User,
        as: 'Likers',
        attributes: ['id'],
      }],
    });
    return res.json(fullPost);
  } 
  catch (err) {
    console.error('/post :::', err);
    next(err);
  }
});
```

```js
// front/store/posts.js

export const state = () => ({
  mainPosts: [],
  imagePaths: [],
});

export const mutations = {
  addMainPost(state, payload) {
    state.mainPosts.unshift(payload);
    state.imagePaths = [];
  },
};

export const actions = {
  add({ commit, state }, payload ) {
    // 서버에 게시글 등록 요청 보냄
    this.$axios.post('/post', 
      { content : payload.content, 
        image : state.imagePaths },
      { 
        withCredentials: true 
    })
    .then((res) => {
      commit('addMainPost', res.data)
    })
    .catch((err) => {
      console.error('add:::', err)
    })
  },
}
```



## 8.  이미지 carousel 로 보여주기

### 1)  과정

- pages/index.vue 에서 PostCard.vue 컴포넌트로 post(v-for="post in mainPosts") 를 보낸다.
- PostCard 에서는 리트윗 했는지와 안 했는지에 따라 글귀를 보여주고, 내용을 표시하기 위해 받은 post를 다시 PostContent.vue 로 보낸다.
- PostContent 에서는 이미지 부분(post.Image)을 PostImages로 보내고, content는 보여준다.
- PostImages 에서 이미지 1개, 2개, 3개 이상인 경우로 나눠서 보내주고, 이미지를 클릭 했을 경우, ImageZoom.vue로 받은 image를 넘겨준다.
- ImageZoom 에서는 받은 image를 캐로제로 보여준다.

### 2)  front/PostImages 

- v-img
  - `contain`: 칸에 이미지가 딱 맞게 조정되어서 들어간다.
  - `cover`: 남는 공간이 없이 이미지를 채운다.(이미지가 짤릴 수 있다.)
  - `aspect-ratio="2"`: 가로: 세로 = 2: 1
- 이미지가 없는 경우 => post.Images 를 빈 배열로 받은 경우, 그 길이를 구하고, 0이면 보여주지 않는다.
- 이미지가 하나인 경우 => 가운데에 표시한다.
- 이미지가 두개인 경우 => div로 `display: flex` 스타일을 넣고, 각각의 사진에 `flex: 1` 스타일을 넣어 div개 2등분이 되게 해서 이미지를 보여준다.
- 이미지가 세개인경우 => 처음 이미지만 보여주고, 나머지는 `...`으로 해서 보여준다.
- 이미지 또는 더보기 버튼을 클릭했을 경우, `zoomImages()` 메서드를 이용해서, 캐로제를 활성할 것인지에 대한 값인 `imageZoomed` 를 true로 바꿔준다.
- ImageZoom.vue 에 `imageZoomed`를 false로 변경시킬 `closeModal()` 메서드를 넘긴다.

```vue
// front/components/PostImages.vue

<template>
  <div v-if="images.length === 0"></div>
  <!-- 이미지가 1개인 경우 -->
  <div v-else-if="images.length === 1">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      @click="zoomImages"
    />
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>

  <!-- 이미지가 2개인 경우 -->
  <div v-else-if="images.length === 2" style="display: flex">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <v-img 
      :src="`http://localhost:3085/${images[1].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>
  
  <!-- 이미지가 3개인 경우 -->
  <div v-else style="display: flex">
    <v-img 
      :src="`http://localhost:3085/${images[0].src}`" 
      contain 
      aspect-ratio="2"
      style="flex: 1"
      @click="zoomImages"
    />
    <div style="flex: 1; align-items: center; justify-content: center; display: flex" @click="zoomImages">
      <div style="text-align: center">
        <v-icon>mdi-dots-horizontal</v-icon>
        <div>더 보기</div>
      </div>
    </div>
    <image-zoom v-if="imageZoomed" :close-modal="closeModal" :images="images" />
  </div>
</template>

<script>
  import ImageZoom from '@/components/ImageZoom.vue';

  export default {
    components: {
      ImageZoom
    },
    props: {
      images: {
        type: Array,
        required: true,
      }
    },
    data() {
      return {
        imageZoomed: false,
      }
    },
    methods: {
      closeModal() {
        this.imageZoomed = false;
      },
      zoomImages() {
        this.imageZoomed = true;
      }
    },
  };
</script>
```

### 3)  front/ImageZoom

- front/PostImages 로 받은 이미지(images) 와 캐로제를 종료시킬 함수(closeModal) 을 props에 등록한다.
- v-for을 이용해 images에 있는 것을 캐로제에 넣어준다.
- 이미지는 `:src="`http://localhost:3085/${img.src}`"` 처럼 db에 있는 그림을 가져온다.

```vue
// front/components/ImageZoom.vue

<template>
  <div id="image-zoom">
    <header>
      <h1>상세 이미지 </h1> <v-icon id="close-btn" @click="closeModal">mdi-close</v-icon>
    </header>
    <div id="carousel-wrapper">
      <v-carousel>
        <v-carousel-item v-for="img in images" :key="img.src">
          <v-sheet>
            <v-img max-height="500" contain :src="`http://localhost:3085/${img.src}`" />
          </v-sheet>
        </v-carousel-item>
      </v-carousel>
    </div>
  </div>
</template>

<script>
  export default {
    props: {
      images: {
        type: Array,
        required: true,
      },
      closeModal: {
        type: Function,
        required: true,
      },
    }
  }
</script>
```



## 9. 리트윗 구현하기

### 1) 요청 주소: `'/:id/retweet'`

### 2) db 생성

- 새로운 글을 생성하면 Post의 고유id가 생성되고, 해당 Post가 리트윗된 글이면, 새로운 글의 Post db는 원본Post의 id를 리트윗id 에 등록한다.
- 즉, Post와 Post 간의 관계가 만들어진다.
- db.Post.belongsTo(db.Post, { as: 설정할이름 })
  - Post 에 설정할이름Id 컬럼이 추가된다. (target의 id가 source로 들어간다.)

### 3) 리트윗 조건 설정

- 로그인 안 한 사용자의 리트윗 요청 무시
- 글이 없는 경우 리트윗 요청 무시
- 작성된 글의 사용자id가 나의 id와 같으면 리트윗 요청 무시
- 내가 한 리트윗 된 글인 경우 또는 내가 작성한 글인 경우 리트윗 요청 무시

### 4) router작성

- 조건을 설정하고, 검사가 끝나면 Post에 UserId와 RetweetId, content를 넘겨서 만든다. (retweet)
- 내가 작성한 글에 원본글이 표시가 되는 형식이다.

```js
// back/routes/post.js

// 리트윗 하기
router.post('/:id/retweet', isLoggedIn, async (req, res, next) => {
  try {
    // 1. 글이 없으면 리트윗 안 됨
    const post = await db.Post.findOne({
      where: { id: req.params.id, },
      include: [{
        model: db.Post,
        as: 'Retweet'
      }]
    })
    if (!post) {
      return res.status(404).send('글이 없는데요;;')
    }
      
    // 2. 글의 유저아이이가 내 id와 같으면 리트윗 하면 안 됨
    if (req.user.id === post.UserId || (post.Retweet && post.Retweet.UserId === req.user.id)) {
      return res.status(403).send('자신의 글을 리트윗할 수 없습니다.');
    }

    // 3. 리트윗 된 글이 또는 작성된 글이 내 글이면 리트윗하면 안 됨
    const retweetTargetId = post.RetweetId || post.id; // 리트윗한 했으면 그 원본 or 원본
    const exPost = await db.Post.findOne({
      where: {
        UserId: req.user.id,
        RetweetId: retweetTargetId,
      }
    })
    if (exPost) {
      return res.status(403).send('이미 리트윗했습니다요')
    }
    // 검사 끝~~

    const retweet = await db.Post.create({
      UserId: req.user.id,
      RetweetId: retweetTargetId, //
      content: '리트윗한 글만 보여줄꺼임~~',
    })
    const retweetWithPrevPost = await db.Post.findOne({
      where: { id: retweet.id },
      include: [{
        model: db.User,
        attributes: ['id', 'nickname']
      }, {
        model:db.Post,
        as: 'Retweet',
        include: [{
          model: db.User,
          attributes: ['id', 'nickname'],
        }, {
          model: db.Image,
        }, {
          model: db.User,
          as: 'Likers',
          attributes: ['id']
        }]
      }]
    })
    res.json(retweetWithPrevPost);
  }
  catch (err) {
    console.error('/:id/retweet :::', err)
    next(err)
  }
});
```

### 5) store 작성

- back에서 작성한 에러메세지는 err.response.data에 들어있다.

```js
// front/store/posts.js

export const mutations = {
  addMainPost(state, payload) {
    state.mainPosts.unshift(payload);
    state.imagePaths = [];
  },
}

export const actions = {
  retweet({ commit }, payload) {
    this.$axios.post(`/post/${payload.postId}/retweet`, {}, {
      withCredentials: true
    })
    .then((res) => {
      // res.data에는 리트윗한 나의 User id, nickname
      // 원본글의 Id와, 글 작성자의 User id, nickname, 글의 image 주소가 들어있다.
      commit('addMainPost', res.data)
    })
    .catch((err) => {
      console.error('retweet:::', err)
      // 작성한 에러메시지
      alert(err.response.data)
    })
  }
}
```

### 6) 리트윗 버튼 수정하기

- 만일 props로 받은 post에 RetweetId가 들어있으면  카드 안에 카드가 들어가는 형식으로 만든다.

```vue
// front/components/PostCard.vue

<template>
  <div>
    <v-card style="margin-bottom: 20px">
      <!-- 리트윗 아아디가 있는 경우 -->
      <div v-if="post.RetweetId && post.Retweet">
        <v-subheader>{{ post.User.nickname }}님이 리트윗했다. </v-subheader>
        <v-card style="margin: 0 20px">
          <post-content :post="post.Retweet" />
        </v-card>
      </div>
        
      <!-- 없는 경우 -->
      <post-content v-else :post="post" />
        
      <v-card-actions>
        <v-btn text color="orange" @click="onRetweet">
          <v-icon>mdi-twitter-retweet</v-icon>
        </v-btn>
      ...
</template>

<script>
  import PostContent from '@/components/PostContent.vue';

  export default {
    components: {
      PostContent,
    },
    props: {
      post: {
        type: Object,
        required: true
      }
    },
    methods: {      
      // 리트윗
      onRetweet() {
        if (!this.me) {
          return alert('로그인이 필요합니다.')
        };
        this.$store.dispatch('posts/retweet', {
          postId: this.post.id,
        });
      },
    },
  }
</script>
```

- 만일 글의 리트윗버튼을 클릭하게 되면, 리트윗 대상 글의 postId가 넘어가서 새로운 글을 만들게 되고, 새로운 글의 retweetId에 리트윗 대상글의 postId가 입력이 된다.

### 7) 리트윗  화면 구현하기

- 리트윗Id가 들어 있는 경우 카드형식으로 보여주기 위해 PostContent.vue 를 생성한다.
- post에 이미지가 있는 경우는 PostImages.vue 로 넘긴다.

```vue
// front/components/POstContent.vue

<template>
  <div>
    <post-images :images="post.Images || []" />
    <v-card-title>
        <h3>
          <nuxt-link :to="/user/ + post.User.id"> {{ post.User.nickname }} </nuxt-link>
        </h3>
      </v-card-title>

      <v-card-text>
        <div>{{ post.content }}</div>
      </v-card-text>
  ...
</template>

<script>
  import PostImages from '@/components/PostImages.vue';

  export default {
    components: {
      PostImages,
    },
    props: {
      post: {
        type: Object,
      }
    },
  }
</script>
```



## 10. 좋아요 구현하기

### 1) 요청주소: `'/:id/like'` 

### 2) db 생성

- 한 사람이 여러 게시글에 좋아요 클릭할 수 있고, 하나의 게시글은 여러 사람의 좋아요를 받을 수 있다.
- `db.Post.belongsToMany(db.User, { through: 'Like', as: 'Likers' })`
- `db.User.belongsToMany(db.Post, { through: 'Like', as: 'Liked' })`

### 3) Route 생성

- 좋아요 는 해당 글이 있으면, 해당 글에 addLiker를 하고, 좋아요 취소는 해당 글에 removeLiker을 한다. 

```js
// back/route/post.js

// 좋아요
router.post('/:id/like', isLoggedIn, async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id, }, })
    if (!post) {
      return res.status(404).send('글이 없는데요;;');
    }
    // 글이 있으면
    await post.addLiker(req.user.id);
    res.json({ userId: req.user.id });
  }
  catch (err) {
    console.error('POST /:id/like :::', err);
    next(err);
  }
});
```

```js
// back/route/post.js

// 좋아요 취소
router.delete('/:id/like', isLoggedIn, async (req, res, next) => {
  try {
    const post = await db.Post.findOne({ where: { id: req.params.id, }, })
    if (!post) {
      return res.status(404).send('글이 없는데요;;');
    }
    // 글이 있으면
    await post.removeLiker(req.user.id);
    res.json({ userId: req.user.id });
  }
  catch (err) {
    console.error('DELETE /:id/like :::', err);
    next(err);
  }
});
```

### 4) Store 생성

- 좋아요를 삭제하는 removeFollowing는 추후 프로필 목록에서 삭제버튼을 구현할 시, 결과를 즉각적으로 보여주기 위해 FollowingList 에서도 삭제한다.

```js
// front/store/users.js

export const state = () => ({
  me: null,
  followerList: [],  
  followingList: [],
});

export const mutations = {
  following(state, payload) {
    state.me.Followings.push({id: payload.userId})
  },
  removeFollowing(state, payload) {
    let targetIndex = state.me.Followings.findIndex(v => v.id === payload.userId)
    state.me.Followings.splice(targetIndex, 1)
    targetIndex = state.followingList.findIndex(v => v.id === payload.userId)
    state.followingList.splice(targetIndex, 1)
  },
};

export const actions = {
  // 팔로워
  follow({ commit }, payload) {
    return this.$axios.post(`/user/${payload.userId}/follow`, {}, {
      withCredentials: true
    })
    .then((res) => {
      commit('following', { userId: payload.userId })
    })
    .catch((err) => {
      console.error('follow :::', err);
    })
  },
  // 언팔로워
  unfollow({ commit }, payload) {
    return this.$axios.delete(`/user/${payload.userId}/follow`, {
      withCredentials: true
    })
    .then((res) => {
      commit('removeFollowing', { userId: payload.userId })
    })
    .catch((err) => {
      console.error('unfollow :::', err);
    })
  },
};
```

### 5) front/PostCard.vue 좋아요 버튼 수정하기

- 좋아요의 모양은 2개이다(채워져 있는 것과 비어있는 것)
- 토글을 만들어 동적으로 사용한다.
- computed() 에 liked()를 만들어서 해당 글에 나의 정보가 들어있는 지 확인한다.
- 해당 글에 나의 정보가 들어있으면 liked()는 true를 반환하고, unlikePost 를 실행시킨다.
- 반대로 나의 정보가 없으면 liked()는 false를 반환하고, likePost를 반환한다.
- alert 경고창은 모든 것을 멈추므로, 실무에서는 직접 구현한다.

```vue
// front/components/PostCard.vue

<template>
  <div>
    <v-card style="margin-bottom: 20px">
        
      <!-- 리트윗 아아디가 있는 경우 -->
      <div v-if="post.RetweetId && post.Retweet">
        <v-subheader>{{ post.User.nickname }}님이 리트윗했다.</v-subheader>
        <v-card style="margin: 0 20px">
          <post-content :post="post.Retweet" />
        </v-card>
      </div>
      <!-- 없는 경우 -->
      <post-content v-else :post="post" />
        
        <!-- 좋아요 -->
        <v-btn text color="orange" @click="onClickHeart">
          <v-icon>{{ heartIcon }}</v-icon>
        </v-btn>
      ...
</template>

<script>
  export default {
    computed: {
      me() {
        return this.$store.state.users.me;
      },
      liked() {
        return !!(this.post.Likers || []).find(v => v.id === (this.me && this.me.id));
      },
      heartIcon() {
        return this.liked ? "mdi-heart" : "mdi-heart-outline";
      }
    },
    methods: {
      // 좋아요
      onClickHeart () {
        if (!this.me) {
          return alert('로그인이 필요합니다.')
        };
        if (this.liked) {
          return this.$store.dispatch('posts/unlikePost', {
            postId: this.post.id,
          })
        };
        return this.$store.dispatch('posts/likePost', {
          postId: this.post.id,
        })
      },
    },
  }
</script>
```



## 11. 팔로우, 팔로워 구현하기

### 1) 요청주소:  `'/:id/follow' `, ` '/:id/follower' `

### 2) db 생성

- 팔로잉, 팔로워는 User간의 N:M 관계이다.
- `db.User.belongsToMany(db.User, { through: 테이블이름 , as: 'Follower'(설정할id이름) foreignKey: followingId(참조할id)})`
  - 내가 나의 follower 를 가져온다면, 다른 유저의 followingId를 참조해서 가져오겠다는 뜻이다.
  - foreignKey는 as에 작성한 것과 반대의 개념으로 이해하면 된다.
- `db.User.belongsToMany(db.User, { through: 'Follow', as: 'Followings', foreignKey: 'followerId' })`
  - Followings 를 불러올때, 다른 유저의 followerId에서 나의 아이디가 있는 user를 가져오겠다는 것이다.

### 3) back/passport/index.js 수정

-  프론트에서 팔로우, 팔로윙 갯수를 보여줄 때 빈 값인 경우 에러가 발생한다.
-  따라서, user에 기본적으로 Follwings와 Followers를 담아서 보내줘야 한다.

### 4)  Router 구현하기

- follow 는 먼저 db.User에서 req.user.id로 로그인한 나를 찾는다.(me)
- 그리고 me에 addFollowing 으로 req.params.id 에 들어있는 otherId(작성자의 id)를 추가한다.
- 프론트에는 내가 좋아야할 글의 사용자id를 넘겨준다(otherId)

```js
// back/routes/user.js

router.post('/:id/follow', isLoggedIn, async (req, res, next) => {
  try {
    const me = await db.User.findOne({
      where: { id: req.user.id, }
    });
    await me.addFollowing(req.params.id);
    res.send(req.params.id);
  }
  catch (err) {
    console.error('POST /:id/follow :::', err);
    next(err);
  }
});
```

### 5)  Store 구현하기

- axios 요청으로 작성자의 아이디인 otherId 를 올려보낸다.

```js
// front/store/users.js


export const state = () => ({
  me: null,
  followerList: [],  
  followingList: [],
}

export const mutations = {
  
  following(state, payload) {
    state.me.Followings.push({id: payload.otherId})
  },
}

export const actions = {
  // 팔로우
  follow({ commit }, payload) {
    return this.$axios.post(`/user/${payload.otherId}/follow`, {}, {
      withCredentials: true
    })
    .then((res) => {
      commit('following', { otherId: payload.otherId })
    })
    .catch((err) => {
      console.error('follow :::', err);
    })
  },
}
```

### 6) 팔로워 팔로워 버튼 구현하기

- canFollow() 로 로그인이 되어있고(this.me) && 글의 작성자가 내가 아니고(this.post.User.id !== this.me.id) && 로그인한 나의 팔로잉에 글작성자의 아이디가 없을 경우(this.me.Followings.find(v => v.id === this.post.User.id)) 팔로우 창이 활성화되게 한다.
- onFollow() 메서드로, 해당 작성자의 id를 otherId에 담아서 스토어에 보낸다.

```vue
// front/components/PostContent.vue

<template>
  <div>
    <post-images :images="post.Images || []" />
    <v-card-title>
        <h3>
          <nuxt-link :to="/user/ + post.User.id"> {{ post.User.nickname }} </nuxt-link>  
          <v-btn v-if="canFollow" @click="onFollow">팔로우</v-btn>
          <v-btn v-if="canUnFollow">언팔로우</v-btn>
  ...
</template>

<script>
  export default {
    computed: {
      me() {
        return this.$store.state.users.me;
      },
      canFollow() {
        return this.me && this.post.User.id !== this.me.id && !this.me.Followings.find(v => v.id === this.post.User.id);
      },
      canUnFollow() {
        return this.me && this.post.User.id !== this.me.id && this.me.Followings.find(v => v.id === this.post.User.id);
      },
    },
    methods: {
      onFollow() {
        this.$store.dispatch('users/follow', {
          otherId: this.post.User.id,
        });
      },
    },
  }
</script>
```

### 7) me에 Followings가  없는 에러가 나타난다면?

- 회원가입 시 또는 로그인 시, user정보에 아이디, 닉네임 이메일 그리고 글의 아이디와 팔로잉, 팔로워를 추가해서 프론트에 넘기도록 한다.(빈값이어도 넘겨야 length에서 에러가 발생하지 않는다.)



## 12. 팔로잉, 팔로워 전체 불러오기

- 팔로잉 전체 목록에 대한 요청이 들어오면, `req.uesr.id` 에 들어있는 나의 정보로 db.User에서 찾는다.(user)
- user에서 Follower 들을 얻기 위해 `getFollowers` 를 사용한다.

```js
// back/routs/user.js

// 팔로우 전체 목록 불러오기
router.get('/:id/followers', isLoggedIn, async (req, res, next) => {
  try {
    const user = await db.User.findOne({ where: { id: req.user.id, } });
    const followers = await user.getFollowers({
      attributes: ['id', 'nickname'],
      limit: parseInt(req.query.limit, 10) || 3,
      offset: parseInt(req.query.offset, 10) || 0,
    });
    res.json(followers);
  }
  catch (err) {
    console.error('/:id/followers :::', err);
    next(err);
  }
})

// 팔로잉 전체 목록 불러오기
router.get('/:id/followings', isLoggedIn, async (req, res, next) => {
  try {
    const user = await db.User.findOne({ where: {  id: req.user.id, } });
    const followings = await user.getFollowings({
      attributes: ['id', 'nickname'],
      limit: parseInt(req.query.limit, 10) || 3,
      offset: parseInt(req.query.offset, 10) || 0,
    })
    res.json(followings)
  }
  catch (err) {
    console.error('/:id/followings :::', err)
    next(err)
  }
})
```

- axios로 offset을 받은 팔로워리스트의 길이를, 받아올 글의 갯수인 limit를 3으로 지정한 뒤 쿼리스트링으로 보낸다.
- axios로 응답을 받으면, data와 함께 offset을 같이 넘긴다.
  - offset을 같이 넘기는 이유는 새로고침 혹은 페이지 전환이 발생하면, 불러온 글이 초기화 되지 않고 전체가 그대로 있기 때문에 offset = 0인 요청의 경우는 받은 데이터로 교체하고, 아니면 concat으로 합친다.
- mutations 에서는 `offset = 0` 이면 `followingList` 를 받은 데이터로 교체하고, `offset` 이 0이 아니면, `followingList`에 추가하게 설정한다.
- axios로 받은 데이터의 크기가 `limit` 와 같지 않으면, `hasMoreFollowing` 을 `false`로 변경시켜, 더이상 목록을 불러오지 않게 한다.

```js
// front/store/user.js

export const state = () => ({
  me: null,
  followerList: [],  
  followingList: [],
  hasMoreFollowing: true,
  hasMoreFollower: true,
});

export const mutations = {
  // 팔로잉 전체 불러오기
  loadFollowings(state, payload) {
    if (payload.offset === 0) {
      state.followingList = payload.data;
    }
    else {
      state.followingList = state.followingList.concat(payload.data);
    }
    state.hasMoreFollowing = payload.data.length === limit;
  },
    
  // 팔로워 전체 불러오기
  loadFollowers(state, payload) {
    if (payload.offset === 0) {
      state.followerList = payload.data;
    }
    else {
      state.followerList = state.followerList.concat(payload.data);
    }
    state.hasMoreFollower = payload.data.length === limit;
  },  
}

export const actions = {
  // 팔로잉 전체 불러오기
  loadFollowings({ commit, state }, payload) {
    if (!(payload && payload.offset === 0) && !state.hasMoreFollowing) {
      return;
    }
    let offset = state.followingList.length;
    if (payload && payload.offset === 0) {
      offset = 0;
    }
    return this.$axios.get(`/user/${state.me.id}/followings?limit=3&offset=${offset}`, {
      withCredentials: true,
      })
      .then((res) => {
        commit('loadFollowings', {
          data: res.data,
          offset,
        });
      })
      .catch((err) => {
        console.error('loadFollowers :::', err)
      });
    },  
    
  // 팔로워 전체 불러오기
  loadFollowers({ commit, state }, payload) {
    if (!(payload && payload.offset === 0) && !state.hasMoreFollower) {
      return;
    }
    let offset = state.followerList.length;
    if (payload && payload.offset === 0) {
      offset = 0;
    }
    return this.$axios.get(`/user/${state.me.id}/followers?limit=3&offset=${offset}`, {
      withCredentials: true,
      })
      .then((res) => {
        commit('loadFollowers', {
          data: res.data,
          offset,
        });
      })
      .catch((err) => {
        console.error('loadFollowers :::', err)
      });
  },
}
```

- `hasMoreFollowing` 이 `true` 이면 버튼을 활성화 시키고, `false` 이면 비활성화 버튼을 나타낸다.
- 더보기 버튼을 클릭할 시, `loadFollowings` 이 실행이 되고, `followingList` 에 데이터가 들어간 뒤, `FollowList` 컴포넌트로 데이터를 보내준다.
- 프로필 페이지로 이동시, 기본적으로 3개의 팔로윙, 팔로워 데이터를 보여주기 위해 `fetch` 를 사용하고, 페이지 이동 및 재렌더링이 될 경우를 위해 `offset = 0` 옵션을 넣어, 초기화 시켜준다.

```vue
// front/pages/profile.vue

<template>
    ...
        <v-container>
          <v-subheader>팔로잉</v-subheader>
          <follow-list :users="followingList" :remove="removeFollowing" />
          <v-btn v-if="hasMoreFollowing" @click="loadFollowings" 
                 color="blue" style="width: 100%">더보기</v-btn>
          <v-btn v-else disabled style="width: 100%">더 보기</v-btn>
        </v-container>
	...
        <v-container>
          <v-subheader>팔로워</v-subheader>
          <follow-list :users="followerList" :remove="removeFollower" />
          <v-btn @click="loadFollowers" v-if="hasMoreFollower" 
                 color="blue" style="width: 100%">더보기</v-btn>
          <v-btn v-else disabled style="width: 100%">더 보기</v-btn>
        </v-container>
	...
</template>

<script>
  import FollowList from '~/components/FollowList'

  export default {
    components: {
      FollowList,
    },
    computed: {
      followerList() {
        return this.$store.state.users.followerList;
      },
      followingList() {
        return this.$store.state.users.followingList;
      },
      hasMoreFollowing() {
        return this.$store.state.users.hasMoreFollowing;
      },
      hasMoreFollower() {
        return this.$store.state.users.hasMoreFollower;
      }
    },
    fetch({ store }) {
      return Promise.all([
        console.log('profile, fetch 들어가요~~'),
        store.dispatch('users/loadFollowers', { offset: 0 }),
        store.dispatch('users/loadFollowings', { offset: 0 })
      ])
    },
    methods: {
      loadFollowers() {
        this.$store.dispatch('users/loadFollowers')
      },
      loadFollowings() {
        this.$store.dispatch('users/loadFollowings')
      },
    },
    middleware: 'authenticated'
  }
</script>
```



## 13. 언팔로우, 언팔로워 구현하기

- 팔로우, 팔로워를 끊기 위해, 끊으려는 다른사용자Id를 받고, removeFllowing 으로 나의 팔로윙 목록에서삭제한다.

```js
// back/routes/user.js

// 언팔로우
router.delete('/:id/follow', isLoggedIn, async (req, res, next) => {
  try {
    const me = await db.User.findOne({
      where: { id: req.user.id },
    });
    await me.removeFollowing(req.params.id);
    res.send(req.params.id)
  }
  catch (err) {
    console.error('DELETE /:id/follow :::', err)
    next(err)
  }
});

// 언팔로워
router.delete('/:id/follower', isLoggedIn, async (req, res, next) => {
  try {
    const me = await db.User.findOne({
      where: { id: req.user.id },
    });
    await me.removeFollower(req.params.id);
    res.send(req.params.id)
  }
  catch (err) {
    console.error('DELETE /:id/follower :::', err)
    next(err)
  }
});
```

- 삭제하려는 사용자의 아이디(`otherId`)를 axios의 delete 요청으로 보낸다.
- mutations 에서는 다른 사용자의 아이디(`otherId`)를 me의 팔로윙목록에서 삭제하고, 전체로 불러온 `follwingList`에서도 삭제를 해준다.

```js
// front/store/user.js

export const state = () => ({
  me: null,
  followerList: [],  
  followingList: [],
});

export const mutations = {
  unfollow(state, payload) {
    let targetIndex = state.me.Followings.findIndex(v => v.id === payload.otherId)
    state.me.Followings.splice(targetIndex, 1)
    targetIndex = state.followingList.findIndex(v => v.id === payload.otherId)
    state.followingList.splice(targetIndex, 1)
  },
  unfollower(state, payload) {
    let targetIndex = state.me.Followers.findIndex(v => v.id === payload.otherId)
    state.me.Followers.splice(targetIndex, 1);
    targetIndex = state.followerList.findIndex(v => v.id === payload.otherId);
    state.followerList.splice(targetIndex, 1);
  },
}

export const actions = {
  // 언팔로우
  unfollow({ commit }, payload) {
    return this.$axios.delete(`/user/${payload.otherId}/follow`, {
      withCredentials: true
    })
    .then((res) => {
      commit('unfollow', { otherId: payload.otherId })
    })
    .catch((err) => {
      console.error('unfollow :::', err);
    })
  },

  // 언팔로워
  unfollower({ commit }, payload) {
    return this.$axios.delete(`/user/${payload.otherId}/follower`, {
      withCredentials: true
    })
    .then((res) => {
      commit('unfollower', { otherId: payload.otherId });
    })
    .catch((err) => {
      console.error('unfollower :::', err);
    })
  },
}
```



## 14. 로그인 시 팔로우, 팔로워, 게시물 수 구현하기

- `front/LoginForm.vue` 에서 state에 있는 me의 정보를 불러오고, `length`로 갯수를 표시한다.
- Post 의 경우, 기본적으로 me에 들어있지 않아므로, back/routes/users에 추가하고 passsprt/index의 deserializer에도 Post를 추가한다.

```vue
// front/components/LoginForm.vue

<template>
 ...,
  <v-container v-else>
    <v-card>
      <v-container>
        {{ me.nickname }} 로그인이 되었습니다.
        <v-btn @click="onLogOut">로그아웃</v-btn>
        <v-row>
          <v-col col="4">{{ me.Followings.length }}명을 팔로잉...</v-col>
          <v-col col="4">{{ me.Followers.length }}명이 나를 팔로워...</v-col>
          <v-col col="4">{{ me.Posts.length }}개의 글을 작성함...</v-col>
  ...
</template>

<script>

  export default {
    computed: {
      me() {
        return this.$store.state.users.me;
      },
    },
  }
</script>
```



## 15. lastId를 활용해 인피니티 스크롤 구현하기

- offset, limit 방식은 글 삭제, 글 추가시 불러오는 목록이 꼬일 수가 있다.
- 따라서, 현재 가지고 있는 글의 마지막의 id를 넘겨서, 해당 글을 기준으로 limit 갯수만큼 불러오도록 한다.
- 또한 지속적인 요청을 제한시키기 위해 throttle도 같이 사용한다.

### 1) throttle 설치

```bash
// front

npm i lodash.throttle
```

### 2) throttle(함수, delay시간) 

- delay 시간은 ms를 의미하고, 3000이면 3초 후 새로 실행이 가능하게 한다는 위미이다.
- front/posts.js 의 loadPosts 부분에 throttle을 사용한다.

```js
// front/store/posts.js

// throttle을 등록한다.
import throttle from 'lodash.throttle'
```

```js
// front/store/posts.js

export const actions = {
  // 쓰로틀링 설정
  loadPosts: throttle( async function({ commit, state }, payload) {
    try {
      if (payload && payload.reset) {
        const res = await this.$axios.get('/posts?limit=10')
        commit('loadPosts', {
          data: res.data,
          reset: true,
        });
        return;
      }
      if (state.hasMorePost) {
        const lastPost = state.mainPosts[state.mainPosts.length - 1];
        const res = await this.$axios.get(`/posts?lastId=${lastPost && lastPost.id}&limit=10`)
        commit('loadPosts', {
          data: res.data,
          reset: false
        });
        return;
      }
    }
    catch (err) {
      console.error('loadPosts :::', err)
    }
  }, 3000),
}
```



## 16. 특정 유저의 글 전부 가져오기

### 1) store 추가하기

- 내(me)가 아닌 다른 사용자를 가져와야 하므로, 다른 사용자의 정보를 담을 other을 새로 만든다.
- 서버에 특정 유저의 id를 담아서 보낸다.(userId)

```js

export const state = () => ({
  mainPosts: [],
  hasMorePost: true,
});

export const mutations = {
  loadPosts(state, payload) {
    if (payload.reset) {
      state.mainPosts = payload.data  
    }
    else {
      state.mainPosts = state.mainPosts.concat(payload.data)
    }
    state.hasMorePost =  payload.data.length === 10;
  },
}

export const actions = {
  // 특정 사람이 작성한 글 가져오기
  loadUserPosts: throttle( async function({ commit, state }, payload) {
    try {
      if (payload && payload.reset) {
        const res = await this.$axios.get(`/user/${payload.userId}/posts?limit=10`, {
          withCredentials: true
        })
        commit('loadPosts', {
          data: res.data,
          reset: true,
        });
        return;
      }
      
      if (state.hasMorePost) {
        const lastPost = state.mainPosts[state.mainPosts.length - 1]
        const res = await this.$axios.get(`/user/${payload.userId}/posts?lastId=${lastPost && lastPost.id}&limit=10`)
        commit('loadPosts', {
          data: res.data,
          reset: false,
        });
        return;
      }
    }
    catch (err) {
      console.error('loadUserPosts :::', err)
    }
  }, 3000),
}
```

### 2) user/_id/index.vue 수정하기

- `front/pages/user/_id/index.vue` 에 fetch, 인피니트스크롤링 등을 적용시킨다.
- `fetch` 에는 this를 사용하지 못하므로, `params`를 사용한다.

```vue
// front/pages/user/_id/index.vue

<template>
  <v-container>
    <v-card style="margin-bottom: 20px">
      <v-container>
        {{ other.nickname }}님은 누굴까요
        <v-row>
          <v-col cols="4"> {{ other.Followings.length }}명을 팔로잉... </v-col>
          <v-col cols="4"> {{ other.Followers.length }}명이 나를 팔로워... </v-col>
          <v-col cols="4"> {{ other.Posts.length }}개의 글을 작성함... </v-col>
        </v-row>
      </v-container>
    </v-card>
    <div>
      <post-card v-for="post in mainPosts" :key="post.id" :post="post" />
    </div>
  </v-container>
</template>

<script>
  import PostCard from '~/components/PostCard';
  
  export default {
    components: {
      PostCard,
    },
    computed: {
      other() {
        return this.$store.state.users.other;
      },
      mainPosts() {
        return this.$store.state.posts.mainPosts;
      },
    },
    fetch({ store, params }) {
      return Promise.all([
        store.dispatch('users/loadOther', {
          userId: params.id,
        }),
        store.dispatch('posts/loadUserPosts', {
          userId: params.id,
          reset: true,
        }),
      ])
    },
    mounted() {
      window.addEventListener('scroll', this.onScroll)
    },
    beforeDestroy() {
      window.removeEventListener('scroll', this.onScroll)
    },
    methods: {
      onScroll() {
        if (window.scrollY + document.documentElement.clientHeight > document.documentElement.scrollHeight - 300) {
          if (this.hasMorePost) {
            this.$store.dispatch('posts/loadUserPosts', {
              userId: this.other.id,
              reset: false
            });
          }
        }
      },
    },
  }
</script>
```

### 3) Routes 추가하기

- 요청 주소: `/user/:id` , `/user/:id/posts`
- 특정 사용자의 정보와 글을를 가져오는 router을 user.js 에 작성한다.

```js
// back/routes/user.js

// 특정 사용자정보 가져오기
router.get('/:id', async (req, res, next) => {
  try {
    const other = await db.User.findOne({
      where: { id: parseInt(req.params.id, 10) },
      attributes: ['id', 'nickname'],
      include: [
        {
        model: db.Post,
        attributes: ['id'],
      }, {
        model: db.User,
        as: 'Followings',
        attributes: ['id'],
      }, {
        model: db.User,
        as: 'Followers',
        attributes: ['id'],
      }],
    });
    res.json(other);
  }
  catch (err) {
    console.error('GET /:id :::', err);
    next(err);
  }
});

// 특정 사용자가 작성한 글 불러오기
router.get('/:id/posts', async (req, res, next) => {
  try {
    let where = {
      UserId: parseInt(req.params.id, 10),
    };
    if (parseInt(req.query.lastId, 10)) {
      where = {
        id: {
          [db.Sequelize.Op.lt]: parseInt(req.query.lastId, 10), // less than
        },
      };
    }
    const posts = await db.Post.findAll({
      where,
      include: [{
        model: db.User,
        attributes: ['id', 'nickname'],
      }, {
        model: db.Image,
      }, {
        model: db.User,
        as: 'Likers',
        attributes: ['id'],
      },{
        model: db.Post,
        as: "Retweet",
        include: [{
            model: db.User,
            attributes: ['id', 'nickname']
          }, {
            model: db.Image
          }
        ]
      }],
      order: [['createdAt', 'DESC']],
      limit: parseInt(req.query.limit, 10) || 10,
    });
    res.json(posts);
  } 
  catch (err) {
    console.error('GET /:id/posts :::', err)
    next(err);
  }
});
```



## 17. 해시태그 구현하기

### 1) 요청 주소: `/hashtag/:id`

- id 에는 글자가 들어간다.

### 2) ERR_UNESCAPED_CHARATER 에러

- 만일 `ERR_UNESCAPED_CHARATER` 에러가 발생한다면 이는 한글을 인식하지 못하는 것이다.
- 프론트에서 한글을 보낼 경우 `encodeURIComponent` 으로  url 전체(인터넷 주소 전체)를 파라미터로 전송한다.
- 백엔드에서는  `decodeURIComponent` 을 사용해서 인코딩한 값을 원래대로 디코딩한다.

### 3) 해시태그 단어 찾기

- 내가 작성한 글안에 #글자, 형식의 해시태그가 포함되어있을 경우, 해당 단어를 찾아야 한다.
- nodes() 로 글자를 공백과 #을 기준으로 작성한 글을 분리한다.
  - 가나다 #라마바 [#사아자 차카타 => nodes: ["가나다 ", "#라마바", " ", "#사아자", " 차카타"]
- nodes에 있는 것을 for문으로 하나씩 접근하고, 만일 시작이 #으로 시작하면, routerLinkTo를 사용해서 페이지를 전환시킨다.

```vue
// front/components/PostContent.vue

<template>
  ...
        <template v-for="(node, i) in nodes">
          <nuxt-link 
            v-if="node.startsWith('#')" 
            :key="i" 
            :to="`/hashtag/${node.slice(1)}`" 
            style="color: deepskyblue" >
            {{node}}
          </nuxt-link>
          <template v-else>{{ node }}</template>
        </template>
  ...
</template>
```

### 4) front/hashtag/_id/index.vue 수정하기

```vue
// front/pages/hashtag/_id/index.vue

<template>
  <v-container>
    <div>
      <post-card v-for="post in mainPosts" :key="post.id" :post="post" />
    </div>
  </v-container>
</template>

<script>
  import PostCard from '~/components/PostCard';

  export default {
    components: {
      PostCard,
    },
    computed: {
      mainPosts() {
        return this.$store.state.posts.mainPosts;
      },
      hasMorePost () {
        return this.$store.state.posts.hasMorePost;
      },
    },
    fetch({ store, params }) {
      return store.dispatch('posts/loadHashtagPosts', {
        hashtag: encodeURIComponent(params.id),
        reset: true,
      });
    },
    mounted() {
      window.addEventListener('scroll', this.onScroll)
    },
    beforeDestroy() {
      window.removeEventListener('scroll', this.onScroll)
    },
    methods: {
      onScroll() {        
        if (window.scrollY + document.documentElement.clientHeight > 
            document.documentElement.scrollHeight - 300) {
          if (this.hasMorePost) {
            const link = document.location.href; 
            const tag = link.split('hashtag/')[1]
            this.$store.dispatch('posts/loadHashtagPosts', {
              hashtag: tag,
              reset: false,
            });
          }
        }
      },
    },
  }
</script>
```

### 5) Store 구현하기

```js
import throttle from 'lodash.throttle'

export const state = () => ({
  mainPosts: [],
  hasMorePost: true,
});

export const mutations = {
  loadPosts(state, payload) {
    if (payload.reset) {
      state.mainPosts = payload.data  
    }
    else {
      state.mainPosts = state.mainPosts.concat(payload.data)
    }
    state.hasMorePost =  payload.data.length === 10;
  },
}

export const actions = {
  // 해시태그 가져오기
  loadHashtagPosts: throttle(async function({ commit, state }, payload) {
    try {
      if (payload && payload.reset) {
        const res = await this.$axios.get(`/hashtag/${payload.hashtag}?limit=10`);
        commit('loadPosts', {
          data: res.data,
          reset: true,
        });
        return;
      }
      if (state.hasMorePost) {
        const lastPost = state.mainPosts[state.mainPosts.length - 1];
        const res = await this.$axios.get(`/hashtag/${payload.hashtag}?lastId=${lastPost && lastPost.id}&limit=10`);
        commit('loadPosts', {
          data: res.data,
        });
        return;
      }
    } catch (err) {
      console.error(err);
    }
  }, 2000),
}
```

### 6) Router 구현하기

```js
// back/routes/hashtag.js

const express = require('express');
const router = express.Router();
const db = require('../models');

// 해시태그 글 가져오기 (// GET /hashtag/:tag?lastId=10&limit=10)
router.get('/:tag', async (req, res, next) => { 
  try {
    let where = {};
    if (parseInt(req.query.lastId, 10)) {
      where = {
        id: {
          [db.Sequelize.Op.lt]: parseInt(req.query.lastId, 10), // less than
        },
      };
    }
    const posts = await db.Post.findAll({
      where,
      include: [{
        model: db.Hashtag,
        where: { name: decodeURIComponent(req.params.tag) },
      }, {
        model: db.User,
        attributes: ['id', 'nickname'],
      }, {
        model: db.Image,
      }, {
        model: db.User,
        as: 'Likers',
        attributes: ['id'],
      }, {
        model: db.Post,
        as: 'Retweet',
        include: [{
          model: db.User,
          attributes: ['id', 'nickname'],
        }, {
          model: db.Image,
        }],
      }],
      order: [['createdAt', 'DESC']],
      limit: parseInt(req.query.limit, 10) || 10,
    });
    res.json(posts);
  } 
  catch (err) {
    console.error('/:tag :::', err)
    next(err);
  }
});

module.exports = router;
```



## 18. 검색기능 추가하기

- 만일 `ERR_UNESCAPED_CHARATER` 에러가 발생한다면 이는 한글을 인식하지 못하는 것이다.
- 프론트에서 한글을 보낼 경우 `encodeURIComponent` 으로  url 전체(인터넷 주소 전체)를 파라미터로 전송한다.
- 백엔드에서는  `decodeURIComponent` 을 사용해서 인코딩한 값을 원래대로 디코딩한다.
- front/layouts에 있는 default.vue 의 검색창에 onSearchHashtag() 메서드를 추가해서 hashtag/_id 로 페이지를 넘긴다.

```vue
// front/layouts/default.vue

<template>
	...,
          <v-form @submit.prevent="onSearchHashtag">
            <div :style="{ display: 'flex', height: '100%', alignItems: 'center' }">
              <v-text-field 
                v-model="hashtag"
                label="검색" 
                hide-details 
                prepend-icon="mdi-magnify" 
              />
            </div>
          </v-form>
	...
</template>

<script>
  export default {
    data() {
      return {
        hashtag: ''
      }
    },
    methods: {
      onSearchHashtag() {
        this.$router.push({
          path: `/hashtag/${encodeURIComponent(this.hashtag)}`,
        }),
        this.hashtag = ''
      }
    },
  }
</script>
```

